; $IdPath$
; List of valid instruction/operand combinations
;
;    Copyright (C) 2001  Peter Johnson
;
;    This file is part of YASM.
;
;    YASM is free software; you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation; either version 2 of the License, or
;    (at your option) any later version.
;
;    YASM is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program; if not, write to the Free Software
;    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
;
; Meanings of codes:
;  $x refers to operand x
;  "nil" in a field indicates the lack of that field in the instruction
;   (there MUST be some text in every field in this document)
;  Sizes are in bits (8,16,32 are the only valid quantities)
;
; Column definitions:
;  Inst     - Instruction, should be lowercase
;  Operands - Single combination of valid operands
;             "TO" is not counted in the operand count.
;  OpSize   - Fixed operand size.  Can generate prefix byte.
;  Opcode   - One or two bytes of opcode.
;  EffAddr  - Effective Address (ModRM/SIB/Off).  First value is the memory
;             operand, second specifies what value goes into the reg/spare
;             bits in the ModRM byte.
;             $xr indicates operand is register, not ModRM (needs convert to RM)
;             $xi indicates operand is immediate (2nd parm is size in bits)
;  Imm      - Immediate source operand and forced size (in bits).
;             "s" after size indicates signed number
;             A number instead of a $x is a hex constant value.
;
; A ':' at the beginning of the line means that the instruction following the
;  ':' is a synonym for the instruction in the 2nd column.
;
; See the parser file for a list of possible operand values and their meanings.
; gen_instr.pl translates this list into lexer and parser code.
;
; Instructions are listed in the same order as that in GNU binutils
;  /include/opcode/i386.h, used for the GAS assembler.  See
;  <http://sources.redhat.com/cgi-bin/cvsweb.cgi/src/include/opcode/i386.h?cvsroot=src>.
;
; TODO:
;  Finish instructions (may require changing parser code).
;  Doublecheck instruction encodings, allowable operands.
;  Doublecheck CPU flags (especially on MMX/SSE/SSE2 opcodes).
;  Doublecheck AMD and Cyrix instructions.
;  Doublecheck the segreg mov instructions.
;
; Instruction Groupings (to shorten parser code).
;  The $0.1, $0.2, and $0.3 will get replaced with the parameters given for
;   the instruction using the group during lexing & parsing.  These parameters
;   may be in the opcode, opsize, effaddr, or immediate.
;  When opsize is a parameter, its usage in instructions that use the group
;   looks slightly different than normal, because the parameters are
;   specified in hexidecimal while the normal opsize usage is in decimal.
;   Thus 10 and 20 are used instead of 16 and 32 respectively.
;  The first CPU grouping for the instruction is OR'ed with the CPU value in
;   the group CPU fields with @0 in their list.  This allows one grouping to
;   be used for instructions with different CPU values.
;  Restrictions on groupings:
;   - $0.? may not appear in the operand, the first part of the effaddr, the
;     second part of the imm, or the CPU fields.
;   - @0, @1 may only appear in the CPU field.
;  Restrictions on instructions based on groupings:
;   - no other operand combinations are allowed (eg, if an instruction uses a
;     group, that must be the ONLY line for the instruction)
;
; Notes on code generation:
;  Each group generates a lex token of the group name (sans !).  Bison rules
;   are generated for each of the operand combinations for the group just as
;   with a regular instruction, except for the addition of the $0.? fields.
;   Each $0.? field is replaced by $1.d? in the generated code (eg,
;   $0.1->$1.d1, etc).
;  When an instruction that uses a group is encountered, eg:
;   inst!grpname  parm1[,parm2[,parm3]]
;  The following lex code is generated:
;   inst { yylval.groupdata[0]=0xparm1; return GRPNAME; }
;  (and additional yylval.groupdata[#-1]=0xparm#; if needed)
;
; KEY
;
; !Grp	Operands		OpSize	Opcode		EffAddr		Imm	CPU
; Inst	Operands		OpSize	Opcode		EffAddr		Imm	CPU
; Inst!Grp		Parameters	CPU @0		CPU @1
;
; Groupings used throughout
;
;  One byte opcode instructions with no operands:
!onebyte	nil		$0.1	$0.2		nil		nil	@0
;  Two byte opcode instructions with no operands:
!twobyte	nil		nil	$0.1,$0.2	nil		nil	@0
;  Three byte opcode instructions with no operands:
!threebyte	nil		nil	$0.1,$0.2,$0.3	nil		nil	@0
;  One byte opcode instructions with general memory operand:
!onebytemem	mem		nil	$0.1		$1,$0.2		nil	@0
;  Two byte opcode instructions with general memory operand:
!twobytemem	mem		nil	$0.1,$0.2	$1,$0.3		nil	@0
;
; Move instructions
;
; opcode arbitrarily picked for next 3 (could be 8A/8B instead of 88/89).
mov	reg8,reg8		nil	88		$1r,$2		nil	8086
mov	reg16,reg16		16	89		$1r,$2		nil	8086
mov	reg32,reg32		32	89		$1r,$2		nil	386
mov	mem,reg8		nil	88		$1,$2		nil	8086
mov	mem8x,reg8		nil	88		$1,$2		nil	8086
mov	mem,reg16		16	89		$1,$2		nil	8086
mov	mem16x,reg16		16	89		$1,$2		nil	8086
mov	mem,reg32		32	89		$1,$2		nil	386
mov	mem32x,reg32		32	89		$1,$2		nil	386
mov	reg8,mem8		nil	8A		$2,$1		nil	8086
mov	reg16,mem16		16	8B		$2,$1		nil	8086
mov	reg32,mem32		32	8B		$2,$1		nil	386
mov	mem,segreg		nil	8C		$1,$2		nil	8086
mov	reg16,segreg		16	8C		$1r,$2		nil	8086
mov	mem16x,segreg		16	8C		$1,$2		nil	8086
mov	reg32,segreg		32	8C		$1r,$2		nil	386
mov	mem32x,segreg		32	8C		$1,$2		nil	386
mov	segreg,mem		nil	8E		$2,$1		nil	8086
mov	segreg,rm16x		nil	8E		$2,$1		nil	8086
mov	segreg,rm32x		nil	8E		$2,$1		nil	386
;mov	reg_al,memoff8
;mov	reg_ax,memoff16
;mov	reg_eax,memoff32
;mov	memoff8,reg_al
;mov	memoff16,reg_ax
;mov	memoff32,reg_eax
mov	reg8,imm8		nil	B0+$1		nil		$2,8	8086
mov	reg16,imm16		16	B8+$1		nil		$2,16	8086
mov	reg32,imm32		32	B8+$1		nil		$2,32	386
mov	mem8x,imm8		nil	C6		$1,0		$2,8	8086
mov	mem,imm8x		nil	C6		$1,0		$2,8	8086
mov	mem16x,imm16		16	C7		$1,0		$2,16	8086
mov	mem,imm16x		16	C7		$1,0		$2,16	8086
mov	mem32x,imm32		32	C7		$1,0		$2,32	8086
mov	mem,imm32x		32	C7		$1,0		$2,32	8086
mov	CRREG_NOTCR4,reg32	nil	0F,22		$2r,$1		nil	386,PRIV
mov	CR4,reg32		nil	0F,22		$2r,$1		nil	P5,PRIV
mov	reg32,CRREG_NOTCR4	nil	0F,20		$1r,$2		nil	386,PRIV
mov	reg32,CR4		nil	0F,20		$1r,$2		nil	P5,PRIV
mov	reg32,DRREG		nil	0F,21		$1r,$2		nil	386,PRIV
mov	DRREG,reg32		nil	0F,23		$2r,$1		nil	386,PRIV
;
; Move with sign/zero extend
;
!movszx	reg16,rm8		16	0F,$0.1		$2,$1		nil	386
!movszx	reg32,rm8x		32	0F,$0.1		$2,$1		nil	386
!movszx	reg32,rm16x		nil	0F,$0.1+1	$2,$1		nil	386
movsx!movszx		BE
movzx!movszx		B6
;
; Push instructions
;
push	mem16x			16	FF		$1,6		nil	8086
push	mem32x			32	FF		$1,6		nil	386
push	reg16			16	50+$1		nil		nil	8086
push	reg32			32	50+$1		nil		nil	386
push	imm8x			nil	6A		nil		$1,8	8086
push	imm16x			16	68		nil		$1,16	8086
push	imm32x			32	68		nil		$1,32	386
push	reg_cs			nil	0E		nil		nil	8086
push	reg_ss			nil	16		nil		nil	8086
push	reg_ds			nil	1E		nil		nil	8086
push	reg_es			nil	06		nil		nil	8086
push	reg_fs			nil	0F,A0		nil		nil	386
push	reg_gs			nil	0F,A8		nil		nil	386
pusha!onebyte		nil,60		186
pushad!onebyte		20,60		386
pushaw!onebyte		10,60		186
;
; Pop instructions
;
pop	mem16x			16	8F		$1,0		nil	8086
pop	mem32x			32	8F		$1,0		nil	386
pop	reg16			16	58+$1		nil		nil	8086
pop	reg32			32	58+$1		nil		nil	386
pop	reg_ds			nil	1F		nil		nil	8086
pop	reg_es			nil	07		nil		nil	8086
pop	reg_ss			nil	17		nil		nil	8086
pop	reg_fs			nil	0F,A1		nil		nil	386
pop	reg_gs			nil	0F,A9		nil		nil	386
popa!onebyte		nil,61		186
popad!onebyte		20,61		386
popaw!onebyte		10,61		186
;
; Exchange instructions
;
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
xchg	reg8,reg8		nil	86		$1r,$2		nil	8086
xchg	mem,reg8		nil	86		$1,$2		nil	8086
xchg	mem8x,reg8		nil	86		$1,$2		nil	8086
xchg	reg8,mem8		nil	86		$2,$1		nil	8086
xchg	reg_ax,reg16		16	90+$2		nil		nil	8086
xchg	reg16,reg_ax		16	90+$1		nil		nil	8086
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
xchg	reg16,reg16		16	87		$1r,$2		nil	8086
xchg	mem,reg16		16	87		$1,$2		nil	8086
xchg	mem16x,reg16		16	87		$1,$2		nil	8086
xchg	reg16,mem16		16	87		$2,$1		nil	8086
xchg	reg_eax,reg32		32	90+$2		nil		nil	386
xchg	reg32,reg_eax		32	90+$1		nil		nil	386
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
xchg	reg32,reg32		32	87		$1r,$2		nil	386
xchg	mem,reg32		32	87		$1,$2		nil	386
xchg	mem32x,reg32		32	87		$1,$2		nil	386
xchg	reg32,mem32		32	87		$2,$1		nil	386
;
; In/out from ports
;
in	reg_al,imm8		nil	E4		nil		$2,8	8086
in	reg_ax,imm8		16	E5		nil		$2,8	8086
in	reg_eax,imm8		32	E5		nil		$2,8	386
in	reg_al,reg_dx		nil	EC		nil		nil	8086
in	reg_ax,reg_dx		16	ED		nil		nil	8086
in	reg_eax,reg_dx		32	ED		nil		nil	386
out	imm8,reg_al		nil	E6		nil		$1,8	8086
out	imm8,reg_ax		16	E7		nil		$1,8	8086
out	imm8,reg_eax		32	E7		nil		$1,8	386
out	reg_dx,reg_al		nil	EE		nil		nil	8086
out	reg_dx,reg_ax		16	EF		nil		nil	8086
out	reg_dx,reg_eax		32	EF		nil		nil	386
;
; Load effective address
;
lea	reg16,mem16		16	8D		$2,$1		nil	8086
lea	reg32,mem32		32	8D		$2,$1		nil	386
;
; Load segment registers from memory
;
lds	reg16,mem		16	C5		$2,$1		nil	8086
lds	reg32,mem		32	C5		$2,$1		nil	386
les	reg16,mem		16	C4		$2,$1		nil	8086
les	reg32,mem		32	C4		$2,$1		nil	386
lfs	reg16,mem		16	0F,B4		$2,$1		nil	386
lfs	reg32,mem		32	0F,B4		$2,$1		nil	386
lgs	reg16,mem		16	0F,B5		$2,$1		nil	386
lgs	reg32,mem		32	0F,B5		$2,$1		nil	386
lss	reg16,mem		16	0F,B2		$2,$1		nil	386
lss	reg32,mem		32	0F,B2		$2,$1		nil	386
;
; Flags register instructions
;
clc!onebyte		nil,F8		8086
cld!onebyte		nil,FC		8086
cli!onebyte		nil,FA		8086
clts!twobyte		nil,0F,06	286,PRIV
cmc!onebyte		nil,F5		8086
lahf!onebyte		nil,9F		8086
sahf!onebyte		nil,9E		8086
pushf!onebyte		nil,9C		8086
pushfd!onebyte		20,9C		386
pushfw!onebyte		10,9C		8086
popf!onebyte		nil,9D		8086
popfd!onebyte		20,9D		386
popfw!onebyte		10,9D		8086
stc!onebyte		nil,F9		8086
std!onebyte		nil,FD		8086
sti!onebyte		nil,FB		8086
;
; Arithmetic
;
;  General arithmetic
!arith	reg_al,imm8		nil	$0.1+4		nil		$2,8	8086
!arith	reg_ax,imm16		16	$0.1+5		nil		$2,16	8086
!arith	reg_eax,imm32		32	$0.1+5		nil		$2,32	386
!arith	reg8,imm8		nil	80		$1r,$0.2	$2,8	8086
!arith	mem8x,imm		nil	80		$1,$0.2		$2,8	8086
!arith	mem,imm8x		nil	80		$1,$0.2		$2,8	8086
!arith	reg16,imm		16	81		$1r,$0.2	$2,16	8086
!arith	mem16x,imm		16	81		$1,$0.2		$2,16	8086
!arith	reg16,imm16x		16	81		$1r,$0.2	$2,16	8086
!arith	mem,imm16x		16	81		$1,$0.2		$2,16	8086
!arith	reg32,imm		32	81		$1r,$0.2	$2,32	386
!arith	mem32x,imm		32	81		$1,$0.2		$2,32	386
!arith	reg32,imm32x		32	81		$1r,$0.2	$2,32	386
!arith	mem,imm32x		32	81		$1,$0.2		$2,32	386
!arith	reg16,imm8x		16	83		$1r,$0.2	$2,8s	8086
!arith	mem16x,imm8x		16	83		$1,$0.2		$2,8s	8086
!arith	reg32,imm8x		32	83		$1r,$0.2	$2,8s	386
!arith	mem32x,imm8x		32	83		$1,$0.2		$2,8s	386
; opcode arbitrarily picked for next 3 (could be $0.1+2/3 instead of $0.1+0/1).
!arith	reg8,reg8		nil	$0.1		$1r,$2		nil	8086
!arith	reg16,reg16		16	$0.1+1		$1r,$2		nil	8086
!arith	reg32,reg32		32	$0.1+1		$1r,$2		nil	386
!arith	mem,reg8		nil	$0.1		$1,$2		nil	8086
!arith	mem8x,reg8		nil	$0.1		$1,$2		nil	8086
!arith	mem,reg16		16	$0.1+1		$1,$2		nil	8086
!arith	mem16x,reg16		16	$0.1+1		$1,$2		nil	8086
!arith	mem,reg32		32	$0.1+1		$1,$2		nil	386
!arith	mem32x,reg32		32	$0.1+1		$1,$2		nil	386
!arith	reg8,mem8		nil	$0.1+2		$2,$1		nil	8086
!arith	reg16,mem16		16	$0.1+3		$2,$1		nil	8086
!arith	reg32,mem32		32	$0.1+3		$2,$1		nil	386
;  INC/DEC
!incdec	rm8x			nil	FE		$1,$0.1		nil	8086
!incdec	mem16x			16	FF		$1,$0.1		nil	8086
!incdec	mem32x			32	FF		$1,$0.1		nil	386
!incdec	reg16			16	$0.2+$1		nil		nil	8086
!incdec	reg32			32	$0.2+$1		nil		nil	386
;  "F6" opcodes (DIV/IDIV/MUL/NEG/NOT):
!groupf6	rm8x		nil	F6		$1,$0.1		nil	8086
!groupf6	rm16x		16	F7		$1,$0.1		nil	8086
!groupf6	rm32x		32	F7		$1,$0.1		nil	386
add!arith		00,0
inc!incdec		0,40
sub!arith		28,5
dec!incdec		1,48
sbb!arith		18,3
cmp!arith		38,7
test	reg_al,imm8		nil	A8		nil		$2,8	8086
test	reg_ax,imm16		16	A9		nil		$2,16	8086
test	reg_eax,imm32		32	A9		nil		$2,32	386
test	reg8,imm8		nil	F6		$1r,0		$2,8	8086
test	mem8x,imm		nil	F6		$1,0		$2,8	8086
test	mem,imm8x		nil	F6		$1,0		$2,8	8086
test	reg16,imm16		16	F7		$1r,0		$2,16	8086
test	mem16x,imm		16	F7		$1,0		$2,16	8086
test	mem,imm16x		16	F7		$1,0		$2,16	8086
test	reg32,imm32		32	F7		$1r,0		$2,32	386
test	mem32x,imm		32	F7		$1,0		$2,32	386
test	mem,imm32x		32	F7		$1,0		$2,32	386
; arbitrary encoding for next 3, picked $1r,$2 instead of $2r,$1
test	reg8,reg8		nil	84		$1r,$2		nil	8086
test	reg16,reg16		16	85		$1r,$2		nil	8086
test	reg32,reg32		32	85		$1r,$2		nil	386
test	mem,reg8		nil	84		$1,$2		nil	8086
test	mem8x,reg8		nil	84		$1,$2		nil	8086
test	mem,reg16		16	85		$1,$2		nil	8086
test	mem16x,reg16		16	85		$1,$2		nil	8086
test	mem,reg32		32	85		$1,$2		nil	386
test	mem32x,reg32		32	85		$1,$2		nil	386
test	reg8,mem8		nil	84		$2,$1		nil	8086
test	reg16,mem16		16	85		$2,$1		nil	8086
test	reg32,mem32		32	85		$2,$1		nil	386
and!arith		20,4
or!arith		08,1
xor!arith		30,6
adc!arith		10,2
neg!groupf6		3
not!groupf6		2
aaa!onebyte		nil,37		8086
aas!onebyte		nil,3F		8086
daa!onebyte		nil,27		8086
das!onebyte		nil,2F		8086
aad	nil			nil	D5,0A		nil		nil	8086
aad	imm8			nil	D5		nil		$1,8	8086
aam	nil			nil	D4,0A		nil		nil	8086
aam	imm8			nil	D4		nil		$1,8	8086
;
; Conversion instructions
;
cbw!onebyte		10,98		8086
cwde!onebyte		20,98		386
cwd!onebyte		10,99		8086
cdq!onebyte		20,99		386
;
; Multiplication and division
;
mul!groupf6		4
imul	rm8x			nil	F6		$1,5		nil	8086
imul	rm16x			16	F7		$1,5		nil	8086
imul	rm32x			32	F7		$1,5		nil	386
imul	reg16,rm16		16	0F,AF		$2,$1		nil	386
imul	reg32,rm32		32	0F,AF		$2,$1		nil	386
imul	reg16,rm16,imm8x	16	6B		$2,$1		$3,8s	186
imul	reg32,rm32,imm8x	32	6B		$2,$1		$3,8s	386
imul	reg16,imm8x		16	6B		$1r,$1		$2,8s	186
imul	reg32,imm8x		32	6B		$1r,$1		$2,8s	386
imul	reg16,rm16,imm16	16	69		$2,$1		$3,16s	186
imul	reg32,rm32,imm32	32	69		$2,$1		$3,32s	386
imul	reg16,imm16		16	69		$1r,$1		$2,16s	186
imul	reg32,imm32		32	69		$1r,$1		$2,32s	386
div!groupf6		6
idiv!groupf6		7
;
; Shifts
;
;  Standard
!shift	rm8x,ONE		nil	D0		$1,$0.1		nil	8086
!shift	rm8x,reg_cl		nil	D2		$1,$0.1		nil	8086
!shift	rm8x,imm8		nil	C0		$1,$0.1		$2,8	186
!shift	rm16x,ONE		16	D1		$1,$0.1		nil	8086
!shift	rm16x,reg_cl		16	D3		$1,$0.1		nil	8086
!shift	rm16x,imm8		16	C1		$1,$0.1		$2,8	186
!shift	rm32x,ONE		32	D1		$1,$0.1		nil	386
!shift	rm32x,reg_cl		32	D3		$1,$0.1		nil	386
!shift	rm32x,imm8		32	C1		$1,$0.1		$2,8	386
;  Doubleword
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!shlrd	reg16,reg16,imm8	16	0F,$0.1		$1r,$2		$3,8	386
!shlrd	mem,reg16,imm8		16	0F,$0.1		$1,$2		$3,8	386
!shlrd	mem16x,reg16,imm8	16	0F,$0.1		$1,$2		$3,8	386
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!shlrd	reg16,reg16,reg_cl	16	0F,$0.1+1	$1r,$2		nil	386
!shlrd	mem,reg16,reg_cl	16	0F,$0.1+1	$1,$2		nil	386
!shlrd	mem16x,reg16,reg_cl	16	0F,$0.1+1	$1,$2		nil	386
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!shlrd	reg32,reg32,imm8	32	0F,$0.1		$1r,$2		$3,8	386
!shlrd	mem,reg32,imm8		32	0F,$0.1		$1,$2		$3,8	386
!shlrd	mem32x,reg32,imm8	32	0F,$0.1		$1,$2		$3,8	386
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!shlrd	reg32,reg32,reg_cl	32	0F,$0.1+1	$1r,$2		nil	386
!shlrd	mem,reg32,reg_cl	32	0F,$0.1+1	$1,$2		nil	386
!shlrd	mem32x,reg32,reg_cl	32	0F,$0.1+1	$1,$2		nil	386
rol!shift		0
ror!shift		1
rcl!shift		2
rcr!shift		3
sal!shift		4
shl!shift		4
shr!shift		5
sar!shift		7
shld!shlrd		A4
shrd!shlrd		AC
;
; Control transfer instructions (unconditional)
;
; Special format for relative targets:
; !Grp/Inst	target		AdSize	ShrtOp	NearOp		ShrtCPU	NearCPU
;
!jmpcall	target		nil	$0.1	$0.2		8086	8086
!jmpcall	imm:imm		nil	$0.3		$2i,nil		$1,16	8086
!jmpcall	WORD imm:imm	16	$0.3		$2i,16		$1,16	8086
!jmpcall	DWORD imm:imm	32	$0.3		$2i,32		$1,16	386
!jmpcall	memfar		nil	FF		$1,$0.4+1	nil	8086
!jmpcall	WORD memfar	16	FF		$1,$0.4+1	nil	8086
!jmpcall	DWORD memfar	32	FF		$1,$0.4+1	nil	386
!jmpcall	mem		nil	FF		$1,$0.4		nil	8086
!jmpcall	rm16x		16	FF		$1,$0.4		nil	8086
!jmpcall	rm32x		32	FF		$1,$0.4		nil	386
call!jmpcall		nil,E8,9A,2
jmp!jmpcall		EB,E9,EA,4
ret!onebyte		nil,C3		8086
retn	nil			nil	C3		nil		nil	8086
retf	nil			nil	CB		nil		nil	8086
retn	imm16			nil	C2		nil		$1,16	8086
retf	imm16			nil	CA		nil		$1,16	8086
enter	imm16,imm8		nil	C8		$1i,16		$2,8	186
leave!onebyte		nil,C9		186
;
; Conditional jumps
;
!jcc		target		nil	70+$0.1	0F,80+$0.1	8086	386
jo!jcc			0
jno!jcc			1
jb!jcc			2
jc!jcc			2
jnae!jcc		2
jnb!jcc			3
jnc!jcc			3
jae!jcc			3
je!jcc			4
jz!jcc			4
jne!jcc			5
jnz!jcc			5
jbe!jcc			6
jna!jcc			6
jnbe!jcc		7
ja!jcc			7
js!jcc			8
jns!jcc			9
jp!jcc			A
jpe!jcc			A
jnp!jcc			B
jpo!jcc			B
jl!jcc			C
jnge!jcc		C
jnl!jcc			D
jge!jcc			D
jle!jcc			E
jng!jcc			E
jnle!jcc		F
jg!jcc			F
jcxz		target		16	E3	nil		8086	8086
jecxz		target		32	E3	nil		386	386
;
; Loop instructions
;
!loopg		target		nil	E0+$0.1	nil		8086	8086
!loopg		target,reg_cx	16	E0+$0.1	nil		8086	8086
!loopg		target,reg_ecx	32	E0+$0.1	nil		386	386
loop!loopg		2
loopz!loopg		1
loope!loopg		1
loopnz!loopg		0
loopne!loopg		0
;
; Set byte on flag instructions
;
!setcc	rm8			nil	0F,90+$0.1	$1,2		nil	386
seto!setcc		0
setno!setcc		1
setb!setcc		2
setc!setcc		2
setnae!setcc		2
setnb!setcc		3
setnc!setcc		3
setae!setcc		3
sete!setcc		4
setz!setcc		4
setne!setcc		5
setnz!setcc		5
setbe!setcc		6
setna!setcc		6
setnbe!setcc		7
seta!setcc		7
sets!setcc		8
setns!setcc		9
setp!setcc		A
setpe!setcc		A
setnp!setcc		B
setpo!setcc		B
setl!setcc		C
setnge!setcc		C
setnl!setcc		D
setge!setcc		D
setle!setcc		E
setng!setcc		E
setnle!setcc		F
setg!setcc		F
;
; String instructions
;
;  NOTE: cmpsd,movsd can't go to !onebyte group because of other variations
cmpsb!onebyte		nil,A6		8086
cmpsw!onebyte		10,A7		8086
cmpsd	nil			32	A7		nil		nil	386
insb!onebyte		nil,6C		8086
insw!onebyte		10,6D		8086
insd!onebyte		20,6D		386
outsb!onebyte		nil,6E		8086
outsw!onebyte		10,6F		8086
outsd!onebyte		20,6F		386
lodsb!onebyte		nil,AC		8086
lodsw!onebyte		10,AD		8086
lodsd!onebyte		20,AD		386
movsb!onebyte		nil,A4		8086
movsw!onebyte		10,A5		8086
movsd	nil			32	A5		nil		nil	386
scasb!onebyte		nil,AE		8086
scasw!onebyte		10,AF		8086
scasd!onebyte		20,AF		386
stosb!onebyte		nil,AA		8086
stosw!onebyte		10,AB		8086
stosd!onebyte		20,AB		386
xlat!onebyte		nil,D7		8086
xlatb!onebyte		nil,D7		8086
;
; Bit manipulation
;
;  Bit tests
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!bittest	reg16,reg16	16	0F,$0.1		$1r,$2		nil	386
!bittest	mem,reg16	16	0F,$0.1		$1,$2		nil	386
!bittest	mem16x,reg16	16	0F,$0.1		$1,$2		nil	386
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!bittest	reg32,reg32	32	0F,$0.1		$1r,$2		nil	386
!bittest	mem,reg32	32	0F,$0.1		$1,$2		nil	386
!bittest	mem32x,reg32	32	0F,$0.1		$1,$2		nil	386
!bittest	reg16,imm8	16	0F,BA		$1r,$0.2	$2,8	386
!bittest	mem16x,imm8	16	0F,BA		$1,$0.2		$2,8	386
!bittest	reg32,imm8	32	0F,BA		$1r,$0.2	$2,8	386
!bittest	mem32x,imm8	32	0F,BA		$1,$0.2		$2,8	386
;  Bit scans
!bsfr	reg16,rm16		16	0F,BC+$0.1	$2,$1		nil	386
!bsfr	reg32,rm32		32	0F,BC+$0.1	$2,$1		nil	386
bsf!bsfr		0
bsr!bsfr		1
bt!bittest		A3,4
btc!bittest		BB,7
btr!bittest		B3,6
bts!bittest		AB,5
;
; Interrupts and operating system instructions
;
int	imm8			nil	CD		nil		$1,8	8086
int3!onebyte		nil,CC		8086
int03!onebyte		nil,CC		8086
into!onebyte		nil,CE		8086
iret!onebyte		nil,CF		8086
iretw!onebyte		10,CF		8086
iretd!onebyte		20,CF		386
rsm!twobyte		0F,AA		P5,SMM
bound	reg16,mem16		16	62		$2,$1		nil	186
bound	reg32,mem32		32	62		$2,$1		nil	386
hlt!onebyte		nil,F4		8086,PRIV
nop!onebyte		nil,90		8086
;
; Protection control
;
;  286 rm16 protected mode group (LLDT/LTR/STR/VERR/VERW):
!prot286	rm16		nil	0F,00		$1,$0.1		nil	286,PROT,@0
arpl	rm16,reg16		nil	63		$1,$2		nil	286,PROT
lar	reg16,rm16		16	0F,02		$2,$1		nil	286,PROT
lar	reg32,rm32		32	0F,02		$2,$1		nil	386,PROT
lgdt!twobytemem		0F,01,2		286,PRIV
lidt!twobytemem		0F,01,3		286,PRIV
lldt!prot286		2		PRIV
lmsw	rm16			nil	0F,01		$1,6		nil	286,PRIV
lsl	reg16,rm16		16	0F,03		$2,$1		nil	286,PROT
lsl	reg32,rm32		32	0F,03		$2,$1		nil	286,PROT
ltr!prot286		3		PRIV
sgdt!twobytemem		0F,01,0		286
sidt!twobytemem		0F,01,1		286
sldt	mem1632			nil	0F,00		$1,0		nil	286
sldt	reg16			16	0F,00		$1r,0		nil	286
sldt	reg32			32	0F,00		$1r,0		nil	386
smsw	mem1632			nil	0F,01		$1,4		nil	286
smsw	reg16			16	0F,01		$1r,4		nil	286
smsw	reg32			32	0F,01		$1r,4		nil	386
str!prot286		1
verr!prot286		4
verw!prot286		5
;
; Floating point instructions
;
;  Load
fld	mem32x			nil	D9		$1,0		nil	8086,FPU
fld	mem64x			nil	DD		$1,0		nil	8086,FPU
fld	mem80x			nil	DB		$1,5		nil	8086,FPU
fld	fpureg			nil	D9,C0+$1	nil		nil	8086,FPU
fild	mem16x			nil	DF		$1,0		nil	8086,FPU
fild	mem32x			nil	DB		$1,0		nil	8086,FPU
fild	mem64x			nil	DF		$1,5		nil	8086,FPU
fbld	mem80			nil	DF		$1,4		nil	8086,FPU
;  Store
fst	mem32x			nil	D9		$1,2		nil	8086,FPU
fst	mem64x			nil	DD		$1,2		nil	8086,FPU
fst	fpureg			nil	DD,D0+$1	nil		nil	8086,FPU
fist	mem16x			nil	DF		$1,2		nil	8086,FPU
fist	mem32x			nil	DB		$1,2		nil	8086,FPU
;  Store (with pop)
fstp	mem32x			nil	D9		$1,3		nil	8086,FPU
fstp	mem64x			nil	DD		$1,3		nil	8086,FPU
fstp	mem80x			nil	DB		$1,7		nil	8086,FPU
fstp	fpureg			nil	DD,D8+$1	nil		nil	8086,FPU
fistp	mem16x			nil	DF		$1,3		nil	8086,FPU
fistp	mem32x			nil	DB		$1,3		nil	8086,FPU
fistp	mem64x			nil	DF		$1,7		nil	8086,FPU
fbstp	mem80			nil	DF		$1,6		nil	8086,FPU
;  Exchange (with ST0)
fxch	fpureg			nil	D9,C8+$1	nil		nil	8086,FPU
fxch	ST0,ST0			nil	D9,C8		nil		nil	8086,FPU
fxch	ST0,FPUREG_NOTST0	nil	D9,C8+$2	nil		nil	8086,FPU
fxch	FPUREG_NOTST0,ST0	nil	D9,C8+$1	nil		nil	8086,FPU
fxch	nil			nil	D9,C9		nil		nil	8086,FPU
;  Comparisons
!fcomg	mem32x			nil	D8		$1,$0.1		nil	8086,FPU
!fcomg	mem64x			nil	DC		$1,$0.1		nil	8086,FPU
!fcomg	fpureg			nil	D8,$0.2+$1	nil		nil	8086,FPU
!fcomg	ST0,fpureg		nil	D8,$0.2+$2	nil		nil	8086,FPU
;  Extended comparisons
!fcomg2	fpureg			nil	$0.1,$0.2+$1	nil		nil	@0,FPU
!fcomg2	ST0,fpureg		nil	$0.1,$0.2+$2	nil		nil	@0,FPU
;  Comparison (without pop)
fcom!fcomg		2,D0
ficom	mem16x			nil	DE		$1,2		nil	8086,FPU
ficom	mem32x			nil	DA		$1,2		nil	8086,FPU
;  Comparison (with pop)
fcomp!fcomg		3,D8
ficomp	mem16x			nil	DE		$1,3		nil	8086,FPU
ficomp	mem32x			nil	DA		$1,3		nil	8086,FPU
fcompp!twobyte		DE,D9		8086,FPU
;  Unordered comparison (with pop)
fucom!fcomg2		DD,E0		286
fucomp!fcomg2		DD,E8		286
fucompp!twobyte		DA,E9		286,FPU
ftst!twobyte		D9,E4		8086,FPU
fxam!twobyte		D9,E5		8086,FPU
;  Load constants into ST0
fld1!twobyte		D9,E8		8086,FPU
fldl2t!twobyte		D9,E9		8086,FPU
fldl2e!twobyte		D9,EA		8086,FPU
fldpi!twobyte		D9,EB		8086,FPU
fldlg2!twobyte		D9,EC		8086,FPU
fldln2!twobyte		D9,ED		8086,FPU
fldz!twobyte		D9,EE		8086,FPU
;  Arithmetic
!farith	mem32x			nil	D8		$1,$0.1		nil	8086,FPU
!farith	mem64x			nil	DC		$1,$0.1		nil	8086,FPU
!farith	fpureg			nil	D8,$0.2+$1	nil		nil	8086,FPU
!farith	ST0,ST0			nil	D8,$0.2		nil		nil	8086,FPU
!farith	ST0,FPUREG_NOTST0	nil	D8,$0.2+$2	nil		nil	8086,FPU
!farith	TO fpureg		nil	DC,$0.3+$1	nil		nil	8086,FPU
!farith	FPUREG_NOTST0,ST0	nil	DC,$0.3+$1	nil		nil	8086,FPU
!farithp	fpureg		nil	DE,$0.1+$1	nil		nil	8086,FPU
!farithp	fpureg,ST0	nil	DE,$0.1+$1	nil		nil	8086,FPU
!fiarith	mem32x		nil	DA		$1,$0.1		nil	8086,FPU
!fiarith	mem16x		nil	DE		$1,$0.1		nil	8086,FPU
fadd!farith		0,C0,C0
faddp!farithp		C0
fiadd!fiarith		0
fsub!farith		4,E0,E8
fisub!fiarith		4
fsubp!farithp		E8
fsubr!farith		5,E8,E0
fisubr!fiarith		5
fsubrp!farithp		E0
;  Multiply
fmul!farith		1,C8,C8
fimul!fiarith		1
fmulp!farithp		C8
;  Divide
fdiv!farith		6,F0,F8
fidiv!fiarith		6
fdivp!farithp		F8
fdivr!farith		7,F8,F0
fidivr!fiarith		7
fdivrp!farithp		F0
;  Other arithmetic
f2xm1!twobyte		D9,F0		8086,FPU
fyl2x!twobyte		D9,F1		8086,FPU
fptan!twobyte		D9,F2		8086,FPU
fpatan!twobyte		D9,F3		8086,FPU
fxtract!twobyte		D9,F4		8086,FPU
fprem1!twobyte		D9,F5		286,FPU
fdecstp!twobyte		D9,F6		8086,FPU
fincstp!twobyte		D9,F7		8086,FPU
fprem!twobyte		D9,F8		8086,FPU
fyl2xp1!twobyte		D9,F9		8086,FPU
fsqrt!twobyte		D9,FA		8086,FPU
fsincos!twobyte		D9,FB		286,FPU
frndint!twobyte		D9,FC		8086,FPU
fscale!twobyte		D9,FD		8086,FPU
fsin!twobyte		D9,FE		286,FPU
fcos!twobyte		D9,FF		286,FPU
fchs!twobyte		D9,E0		8086,FPU
fabs!twobyte		D9,E1		8086,FPU
;  Processor control
fninit!twobyte		DB,E3		8086,FPU
finit!threebyte		9B,DB,E3	8086,FPU
fldcw	mem16			nil	D9		$1,5		nil	8086,FPU
fnstcw	mem16			nil	D9		$1,7		nil	8086,FPU
fstcw	mem16			nil	9B,D9		$1,7		nil	8086,FPU
fnstsw	mem16			nil	DD		$1,7		nil	8086,FPU
fnstsw	reg_ax			nil	DF,E0		nil		nil	8086,FPU
fstsw	mem16			nil	9B,DD		$1,7		nil	8086,FPU
fstsw	reg_ax			nil	9B,DF,E0	nil		nil	8086,FPU
fnclex!twobyte		DB,E2		8086,FPU
fclex!threebyte		9B,DB,E2	8086,FPU
fnstenv!onebytemem	D9,6		8086,FPU
fstenv!twobytemem	9B,D9,6		8086,FPU
fldenv!onebytemem	D9,4		8086,FPU
fnsave!onebytemem	DD,6		8086,FPU
fsave!twobytemem	9B,DD,6		8086,FPU
frstor!onebytemem	DD,4		8086,FPU
ffree	fpureg			nil	DD,C0+$1	nil		nil	8086,FPU
ffreep	fpureg			nil	DF,C0+$1	nil		nil	P6,FPU,UNDOC
fnop!twobyte		D9,D0		8086,FPU
fwait!onebyte		nil,9B		8086,FPU
;
; Prefixes (should the others be here too? should wait be a prefix?)
;
wait!onebyte		nil,9B		8086
;
; 486 extensions
;
;  Compare & exchange, exchange & add
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!cmpxchgxadd	reg8,reg8	nil	0F,$0.1		$1r,$2		nil	@0
!cmpxchgxadd	mem,reg8	nil	0F,$0.1		$1,$2		nil	@0
!cmpxchgxadd	mem8x,reg8	nil	0F,$0.1		$1,$2		nil	@0
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!cmpxchgxadd	reg16,reg16	16	0F,$0.1+1	$1r,$2		nil	@0
!cmpxchgxadd	mem,reg16	16	0F,$0.1+1	$1,$2		nil	@0
!cmpxchgxadd	mem16x,reg16	16	0F,$0.1+1	$1,$2		nil	@0
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!cmpxchgxadd	reg32,reg32	32	0F,$0.1+1	$1r,$2		nil	@0
!cmpxchgxadd	mem,reg32	32	0F,$0.1+1	$1,$2		nil	@0
!cmpxchgxadd	mem32x,reg32	32	0F,$0.1+1	$1,$2		nil	@0
bswap	reg32			32	0F,C8+$1	nil		nil	486
xadd!cmpxchgxadd	C0		486
cmpxchg!cmpxchgxadd	B0		486
cmpxchg486!cmpxchgxadd	A6		486,UNDOC
invd!twobyte		0F,08		486,PRIV
wbinvd!twobyte		0F,09		486,PRIV
invlpg!twobytemem	0F,01,7		486,PRIV
;
; 586 and late 486 extensions
;
cpuid!twobyte		0F,A2		486
;
; Pentium extensions
;
wrmsr!twobyte		0F,30		P5,PRIV
rdtsc!twobyte		0F,31		P5
rdmsr!twobyte		0F,32		P5,PRIV
cmpxchg8b	mem64		nil	0F,C7		$1,1		nil	P5
;
; Pentium II/Pentium Pro extensions
;
sysenter!twobyte	0F,34		P6
sysexit!twobyte		0F,35		P6,PRIV
fxsave!twobytemem	0F,AE,0		P6,FPU
fxrstor!twobytemem	0F,AE,1		P6,FPU
rdpmc!twobyte		0F,33		P6
ud2!twobyte		0F,0B		286
ud1!twobyte		0F,B9		286,UNDOC
; cmov
; fcmov
fcomi!fcomg2		DB,F0		P6
fucomi!fcomg2		DB,E8		P6
fcomip!fcomg2		DF,F0		P6
fucomip!fcomg2		DF,E8		P6
;
; Pentium4 extensions
;
movnti	mem32,reg32		nil	0F,C3		$1,$2		nil	P4
clflush	mem8			nil	0F,AE		$1,7		nil	KATMAI
lfence!threebyte	0F,AE,E8	KATMAI
mfence!threebyte	0F,AE,F0	KATMAI
pause!twobyte		F3,90		P4
;
; MMX/SSE2 instructions
;
;  General
!mmxsse	MMXREG,rm64		nil	0F,$0.1		$2,$1		nil	@0,MMX
!mmxsse	XMMREG,rm128		nil	66,0F,$0.1	$2,$1		nil	@1
;  Shifts
!pshift	MMXREG,rm64		nil	0F,$0.1		$2,$1		nil	P5,MMX
!pshift	XMMREG,rm128		nil	66,0F,$0.1	$2,$1		nil	P4,SSE2
!pshift	MMXREG,imm8		nil	0F,$0.2		$1r,$0.3	$2,8	P5,MMX
!pshift	XMMREG,imm8		nil	66,0F,$0.2	$1r,$0.3	$2,8	P4,SSE2
emms!twobyte		0F,77		P5,MMX
movd	MMXREG,rm32		nil	0F,6E		$2,$1		nil	P5,MMX
movd	rm32,MMXREG		nil	0F,7E		$1,$2		nil	P5,MMX
movd	XMMREG,rm32		nil	66,0F,6E	$2,$1		nil	P4,SSE2
movd	rm32,XMMREG		nil	66,0F,7E	$1,$2		nil	P4,SSE2
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movq	MMXREG,MMXREG		nil	0F,6F		$2r,$1		nil	P5,MMX
movq	MMXREG,mem64		nil	0F,6F		$2,$1		nil	P5,MMX
movq	mem64,MMXREG		nil	0F,7F		$1,$2		nil	P5,MMX
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movq	XMMREG,XMMREG		nil	F3,0F,7E	$2r,$1		nil	P4,SSE2
movq	XMMREG,mem64		nil	F3,0F,7E	$2,$1		nil	P4,SSE2
movq	mem64,XMMREG		nil	66,0F,D6	$1,$2		nil	P4,SSE2
packssdw!mmxsse		6B		P5		P4,SSE2
packsswb!mmxsse		63		P5		P4,SSE2
packuswb!mmxsse		67		P5		P4,SSE2
paddb!mmxsse		FC		P5		P4,SSE2
paddw!mmxsse		FD		P5		P4,SSE2
paddd!mmxsse		FE		P5		P4,SSE2
paddq!mmxsse		D4		P5		P4,SSE2
paddsb!mmxsse		EC		P5		P4,SSE2
paddsw!mmxsse		ED		P5		P4,SSE2
paddusb!mmxsse		DC		P5		P4,SSE2
paddusw!mmxsse		DD		P5		P4,SSE2
pand!mmxsse		DB		P5		P4,SSE2
pandn!mmxsse		DF		P5		P4,SSE2
pcmpeqb!mmxsse		74		P5		P4,SSE2
pcmpeqw!mmxsse		75		P5		P4,SSE2
pcmpeqd!mmxsse		76		P5		P4,SSE2
pcmpgtb!mmxsse		64		P5		P4,SSE2
pcmpgtw!mmxsse		65		P5		P4,SSE2
pcmpgtd!mmxsse		66		P5		P4,SSE2
pmaddwd!mmxsse		F5		P5		P4,SSE2
pmulhw!mmxsse		E5		P5		P4,SSE2
pmullw!mmxsse		D5		P5		P4,SSE2
por!mmxsse		EB		P5		P4,SSE2
psllw!pshift		F1,71,6
pslld!pshift		F2,72,6
psllq!pshift		F3,73,6
psraw!pshift		E1,71,4
psrad!pshift		E2,72,4
psrlw!pshift		D1,71,2
psrld!pshift		D2,72,2
psrlq!pshift		D3,73,2
psubb	MMXREG,imm8		nil	0F,F8		$1r,2		$2,8	P5,MMX
psubb	XMMREG,imm8		nil	66,0F,F8	$1r,2		$2,8	P4,SSE2
psubw	MMXREG,imm8		nil	0F,F9		$1r,2		$2,8	P5,MMX
psubw	XMMREG,imm8		nil	66,0F,F9	$1r,2		$2,8	P4,SSE2
psubd!mmxsse		FA		P5		P4,SSE2
psubq!mmxsse		FB		P5		P4,SSE2
psubsb!mmxsse		E8		P5		P4,SSE2
psubsw!mmxsse		E9		P5		P4,SSE2
psubusb!mmxsse		D8		P5		P4,SSE2
psubusw!mmxsse		D9		P5		P4,SSE2
punpckhbw!mmxsse	68		P5		P4,SSE2
punpckhwd!mmxsse	69		P5		P4,SSE2
punpckhdq!mmxsse	6A		P5		P4,SSE2
punpcklbw!mmxsse	60		P5		P4,SSE2
punpcklwd!mmxsse	61		P5		P4,SSE2
punpckldq!mmxsse	62		P5		P4,SSE2
pxor!mmxsse		EF		P5		P4,SSE2
;
; PIII (Katmai) new instructions / SIMD instructions
;
;  Standard
!sseps	XMMREG,rm128		nil	0F,$0.1		$2,$1		nil	@0
!ssess	XMMREG,rm128		nil	F3,0F,$0.1	$2,$1		nil	@0
;  With immediate
!ssepsimm	XMMREG,rm128,imm8	nil	0F,$0.1	$2,$1		$3,8	KATMAI,SSE
;  Comparisons
!ssecmpps	XMMREG,rm128	nil	0F,C2		$2,$1		$0.1,8	KATMAI,SSE
!ssecmpss	XMMREG,rm128	nil	F3,0F,C2	$2,$1		$0.1,8	KATMAI,SSE
addps!sseps		58		KATMAI,SSE
addss!ssess		58		KATMAI,SSE
andnps!sseps		55		KATMAI,SSE
andps!sseps		54		KATMAI,SSE
cmpeqps!ssecmpps	0
cmpeqss!ssecmpss	0
cmpleps!ssecmpps	2
cmpless!ssecmpss	2
cmpltps!ssecmpps	1
cmpltss!ssecmpss	1
cmpneqps!ssecmpps	4
cmpneqss!ssecmpss	4
cmpnleps!ssecmpps	6
cmpnless!ssecmpss	6
cmpnltps!ssecmpps	5
cmpnltss!ssecmpss	5
cmpordps!ssecmpps	7
cmpordss!ssecmpss	7
cmpunordps!ssecmpps	3
cmpunordss!ssecmpss	3
cmpps!ssepsimm		C2
cmpss	XMMREG,rm128,imm8	nil	F3,0F,C2	$2,$1		$3,8	KATMAI,SSE
comiss!sseps		2F		KATMAI,SSE
cvtpi2ps!sseps		2A		KATMAI,SSE
cvtps2pi!sseps		2D		KATMAI,SSE
cvtsi2ss!ssess		2A		KATMAI,SSE
cvtss2si!ssess		2D		KATMAI,SSE
cvttps2pi!sseps		2C		KATMAI,SSE
cvttss2si!ssess		2C		KATMAI,SSE
divps!sseps		5E		KATMAI,SSE
divss!ssess		5E		KATMAI,SSE
ldmxcsr	mem32			nil	0F,AE		$1,2		nil	KATMAI,SSE
maskmovq	MMXREG,MMXREG	nil	0F,F7		$2r,$1		nil	KATMAI,MMX
maxps!sseps		5F		KATMAI,SSE
maxss!ssess		5F		KATMAI,SSE
minps!sseps		5D		KATMAI,SSE
minss!ssess		5D		KATMAI,SSE
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movaps	XMMREG,XMMREG		nil	0F,28		$2r,$1		nil	KATMAI,SSE
movaps	XMMREG,mem128		nil	0F,28		$2,$1		nil	KATMAI,SSE
movaps	mem128,XMMREG		nil	0F,29		$1,$2		nil	KATMAI,SSE
movhlps	XMMREG,XMMREG		nil	0F,12		$2r,$1		nil	KATMAI,SSE
movhps	XMMREG,mem64		nil	0F,16		$2,$1		nil	KATMAI,SSE
movhps	mem64,XMMREG		nil	0F,17		$1,$2		nil	KATMAI,SSE
movlhps	XMMREG,XMMREG		nil	0F,16		$2r,$1		nil	KATMAI,SSE
movlps	XMMREG,mem64		nil	0F,12		$2,$1		nil	KATMAI,SSE
movlps	mem64,XMMREG		nil	0F,13		$1,$2		nil	KATMAI,SSE
movmskps	reg32,XMMREG	nil	0F,50		$1r,$2		nil	KATMAI,SSE
movntps	mem128,XMMREG		nil	0F,2B		$1,$2		nil	KATMAI,SSE
movntq	mem64,MMXREG		nil	0F,E7		$1,$2		nil	KATMAI,MMX
movntdq	mem128,XMMREG		nil	66,0F,E7	$1,$2		nil	P4,SSE2
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movss	XMMREG,XMMREG		nil	F3,0F,10	$2r,$1		nil	KATMAI,SSE
movss	XMMREG,mem64		nil	F3,0F,10	$2,$1		nil	KATMAI,SSE
movss	mem64,XMMREG		nil	F3,0F,11	$1,$2		nil	KATMAI,SSE
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movups	XMMREG,XMMREG		nil	0F,10		$2r,$1		nil	KATMAI,SSE
movups	XMMREG,mem64		nil	0F,10		$2,$1		nil	KATMAI,SSE
movups	mem64,XMMREG		nil	0F,11		$1,$2		nil	KATMAI,SSE
mulps!sseps		59		KATMAI,SSE
mulss!ssess		59		KATMAI,SSE
orps!sseps		56		KATMAI,SSE
pavgb!mmxsse		E0		KATMAI		P4,SSE2
pavgw!mmxsse		E3		KATMAI		P4,SSE2
pextrw	reg32,MMXREG,imm8	nil	0F,C5		$1r,$2		$3,8	KATMAI,MMX
pextrw	reg32,XMMREG,imm8	nil	66,0F,C5	$1r,$2		$3,8	P4,SSE2
pinsrw	MMXREG,reg32,imm8	nil	0F,C4		$2r,$1		$3,8	KATMAI,MMX
pinsrw	MMXREG,rm16,imm8	nil	0F,C4		$2,$1		$3,8	KATMAI,MMX
pinsrw	XMMREG,reg32,imm8	nil	66,0F,C4	$2r,$1		$3,8	P4,SSE2
pinsrw	XMMREG,rm16,imm8	nil	66,0F,C4	$2,$1		$3,8	P4,SSE2
pmaxsw!mmxsse		EE		KATMAI		P4,SSE2
pmaxub!mmxsse		DE		KATMAI		P4,SSE2
pminsw!mmxsse		EA		KATMAI		P4,SSE2
pminub!mmxsse		DA		KATMAI		P4,SSE2
pmovmskb	reg32,MMXREG	nil	0F,D7		$1r,$2		nil	KATMAI,SSE
pmovmskb	reg32,XMMREG	nil	66,0F,D7	$1r,$2		nil	P4,SSE2
pmulhuw!mmxsse		E4		KATMAI		P4,SSE2
prefetchnta!twobytemem	0F,18,0		KATMAI
prefetcht0!twobytemem	0F,18,1		KATMAI
prefetcht1!twobytemem	0F,18,2		KATMAI
prefetcht2!twobytemem	0F,18,3		KATMAI
psadbw!mmxsse		F6		KATMAI		KATMAI,SSE
pshufw	MMXREG,rm64,imm8	nil	0F,70		$2,$1		$3,8	KATMAI,MMX
rcpps!sseps		53		KATMAI,SSE
rcpss!ssess		53		KATMAI,SSE
rsqrtps!sseps		52		KATMAI,SSE
rsqrtss!ssess		52		KATMAI,SSE
sfence!threebyte	0F,AE,F8	KATMAI
shufps!ssepsimm		C6
sqrtps!sseps		51		KATMAI,SSE
sqrtss!ssess		51		KATMAI,SSE
stmxcsr	mem32			nil	0F,AE		$1,3		nil	KATMAI,SSE
subps!sseps		5C		KATMAI,SSE
subss!ssess		5C		KATMAI,SSE
ucomiss!ssess		2E		KATMAI,SSE
unpckhps!sseps		15		KATMAI,SSE
unpcklps!sseps		14		KATMAI,SSE
xorps!sseps		57		KATMAI,SSE
;
; SSE2 instructions
;
;  Standard
!sse2pd	XMMREG,rm128		nil	66,0F,$0.1	$2,$1		nil	P4,SSE2
!sse2sd	XMMREG,rm128		nil	F2,0F,$0.1	$2,$1		nil	P4,SSE2
;  With immediate
!sse2pdimm	XMMREG,rm128,imm8	nil	66,0F,$0.1	$2,$1	$3,8	P4,SSE2
;  Comparisons
!sse2cmppd	XMMREG,rm128	nil	66,0F,C2	$2,$1		$0.1,8	P4,SSE2
!sse2cmpsd	XMMREG,rm128	nil	F2,0F,C2	$2,$1		$0.1,8	P4,SSE2
addpd!sse2pd		58
addsd!sse2sd		58
andnpd!sse2pd		55
andpd!sse2pd		54
cmpeqpd!sse2cmppd	0
cmpeqsd!sse2cmpsd	0
cmplepd!sse2cmppd	2
cmplesd!sse2cmpsd	2
cmpltpd!sse2cmppd	1
cmpltsd!sse2cmpsd	1
cmpneqpd!sse2cmppd	4
cmpneqsd!sse2cmpsd	4
cmpnlepd!sse2cmppd	6
cmpnlesd!sse2cmpsd	6
cmpnltpd!sse2cmppd	5
cmpnltsd!sse2cmpsd	5
cmpordpd!sse2cmppd	7
cmpordsd!sse2cmpsd	7
cmpunordpd!sse2cmppd	3
cmpunordsd!sse2cmpsd	3
cmppd!sse2pdimm		C2
cmpsd	XMMREG,rm128,imm8	nil	F2,0F,C2	$2,$1		$3,8	P4,SSE2
comisd!sse2pd		2F
cvtpi2pd!sse2pd		2A
cvtsi2sd!sse2sd		2A
divpd!sse2pd		5E
divsd!sse2sd		5E
maxpd!sse2pd		5F
maxsd!sse2sd		5F
minpd!sse2pd		5D
minsd!sse2sd		5D
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movapd	XMMREG,XMMREG		nil	66,0F,28	$2r,$1		nil	P4,SSE2
movapd	XMMREG,mem128		nil	66,0F,28	$2,$1		nil	P4,SSE2
movapd	mem128,XMMREG		nil	66,0F,29	$1,$2		nil	P4,SSE2
movhpd	XMMREG,mem64		nil	66,0F,16	$2,$1		nil	P4,SSE2
movhpd	mem64,XMMREG		nil	66,0F,17	$1,$2		nil	P4,SSE2
movlpd	XMMREG,mem64		nil	66,0F,12	$2,$1		nil	P4,SSE2
movlpd	mem64,XMMREG		nil	66,0F,13	$1,$2		nil	P4,SSE2
movmskpd	reg32,XMMREG	nil	66,0F,50	$1r,$2		nil	P4,SSE2
movntpd	mem128,XMMREG		nil	66,0F,2B	$1,$2		nil	P4,SSE2
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movsd	XMMREG,XMMREG		nil	F2,0F,10	$2r,$1		nil	P4,SSE2
movsd	XMMREG,mem64		nil	F2,0F,10	$2,$1		nil	P4,SSE2
movsd	mem64,XMMREG		nil	F2,0F,11	$1,$2		nil	P4,SSE2
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movupd	XMMREG,XMMREG		nil	66,0F,10	$2r,$1		nil	P4,SSE2
movupd	XMMREG,mem64		nil	66,0F,10	$2,$1		nil	P4,SSE2
movupd	mem64,XMMREG		nil	66,0F,11	$1,$2		nil	P4,SSE2
mulpd!sse2pd		59
mulsd!sse2sd		59
orpd!sse2pd		56
shufpd!sse2pdimm	C6
sqrtpd!sse2pd		51
sqrtsd!sse2sd		51
subpd!sse2pd		5C
subsd!sse2sd		5C
ucomisd!sse2sd		2E
unpckhpd!sse2pd		15
unpcklpd!sse2pd		14
xorpd!sse2pd		57
cvtdq2pd!ssess		E6		P4,SSE2
cvtpd2dq!sse2sd		E6
cvtdq2ps!sseps		5B		P4,SSE2
cvtpd2pi!sse2pd		2D
cvtpd2ps!sse2pd		5A
cvtps2pd!sseps		5A		P4,SSE2
cvtps2dq!sse2pd		5B
cvtsd2si!sse2sd		2D
cvtsd2ss!sse2sd		5A
cvtss2sd!ssess		5A		P4,SSE2
cvttpd2pi!sse2pd	2C
cvttsd2si!sse2sd	2C
cvttpd2dq!sse2pd	E6
cvttps2dq!ssess		5B		P4,SSE2
maskmovdqu	XMMREG,XMMREG	nil	66,0F,F7	$2r,$1		nil	P4,SSE2
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movdqa	XMMREG,XMMREG		nil	66,0F,6F	$2r,$1		nil	P4,SSE2
movdqa	XMMREG,mem128		nil	66,0F,6F	$2,$1		nil	P4,SSE2
movdqa	mem128,XMMREG		nil	66,0F,7F	$1,$2		nil	P4,SSE2
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movdqu	XMMREG,XMMREG		nil	F3,0F,6F	$2r,$1		nil	P4,SSE2
movdqu	XMMREG,mem128		nil	F3,0F,6F	$2,$1		nil	P4,SSE2
movdqu	mem128,XMMREG		nil	F3,0F,7F	$1,$2		nil	P4,SSE2
movdq2q	MMXREG,XMMREG		nil	F2,0F,D6	$2r,$1		nil	P4,SSE2
movq2dq	XMMREG,MMXREG		nil	F3,0F,D6	$2r,$1		nil	P4,SSE2
pmuludq!mmxsse		F4		P4		P4,SSE2
pshufd!sse2pdimm	70
pshufhw	XMMREG,rm128,imm8	nil	F3,0F,70	$2,$1		$3,8	P4,SSE2
pshuflw	XMMREG,rm128,imm8	nil	F2,0F,70	$2,$1		$3,8	P4,SSE2
pslldq	XMMREG,imm8		nil	66,0F,73	$1r,7		$2,8	P4,SSE2
psrldq	XMMREG,imm8		nil	66,0F,73	$1r,3		$2,8	P4,SSE2
punpckhqdq!sse2pd	6D
punpcklqdq!sse2pd	6C
;
; AMD 3DNow! instructions
;
!now3d	MMXREG,rm64		nil	0F,0F		$2,$1		$0.1,8	@0,3DNOW,AMD
prefetch!twobytemem	0F,0D,0		P5,3DNOW,AMD
prefetchw!twobytemem	0F,0D,1		P5,3DNOW,AMD
femms!twobyte		0F,0E		P5,3DNOW,AMD
pavgusb!now3d		BF		P5
pf2id!now3d		1D		P5
pf2iw!now3d		1C		ATHLON
pfacc!now3d		AE		P5
pfadd!now3d		9E		P5
pfcmpeq!now3d		B0		P5
pfcmpge!now3d		90		P5
pfcmpgt!now3d		A0		P5
pfmax!now3d		A4		P5
pfmin!now3d		94		P5
pfmul!now3d		B4		P5
pfnacc!now3d		8A		ATHLON
pfpnacc!now3d		8E		ATHLON
pfrcp!now3d		96		P5
pfrcpit1!now3d		A6		P5
pfrcpit2!now3d		B6		P5
pfrsqit1!now3d		A7		P5
pfrsqrt!now3d		97		P5
pfsub!now3d		9A		P5
pfsubr!now3d		AA		P5
pi2fd!now3d		0D		P5
pi2fw!now3d		0C		ATHLON
pmulhrwa!now3d		B7		P5
pswapd!now3d		BB		ATHLON
;
; AMD extensions
;
syscall!twobyte		0F,05		P6,AMD
sysret!twobyte		0F,07		P6,PRIV,AMD
; swapgs
;
; Cyrix MMX instructions
;
!cyrixmmx	MMXREG,rm64	nil	0F,$0.1		$2,$1		nil	P5,MMX,CYRIX
paddsiw!cyrixmmx	51
paveb!cyrixmmx		50
pdistib!cyrixmmx	54
pmachriw	MMXREG,mem64	nil	0F,5E		$2,$1		nil	P5,MMX,CYRIX
pmagw!cyrixmmx		52
pmulhriw!cyrixmmx	5D
pmulhrwc!cyrixmmx	59
pmvgezb!cyrixmmx	5C
pmvlzb!cyrixmmx		5B
pmvnzb!cyrixmmx		5A
pmvzb!cyrixmmx		58
psubsiw!cyrixmmx	55
;
; Cyrix extensions
;
!cyrixsmm	mem80		nil	0F,$0.1		$1,0		nil	486,CYRIX,SMM
rdshr!twobyte		0F,36		P6,CYRIX,SMM
rsdc	segreg,mem80		nil	0F,79		$2,$1		nil	486,CYRIX,SMM
rsldt!cyrixsmm		7B
rsts!cyrixsmm		7D
svdc	mem80,segreg		nil	0F,78		$1,$2		nil	486,CYRIX,SMM
svldt!cyrixsmm		7A
svts!cyrixsmm		7C
smint!twobyte		0F,38		P6,CYRIX
smintold!twobyte	0F,7E		486,CYRIX,OBS
wrshr!twobyte		0F,37		P6,CYRIX,SMM
;
; Obsolete/Undocumented Instructions
;
fsetpm!twobyte		DB,E4		286,FPU,OBS
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
ibts	reg16,reg16		16	0F,A7		$1r,$2		nil	386,UNDOC,OBS
ibts	mem,reg16		16	0F,A7		$1,$2		nil	386,UNDOC,OBS
ibts	mem16x,reg16		16	0F,A7		$1,$2		nil	386,UNDOC,OBS
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
ibts	reg32,reg32		32	0F,A7		$1r,$2		nil	386,UNDOC,OBS
ibts	mem,reg32		32	0F,A7		$1,$2		nil	386,UNDOC,OBS
ibts	mem32x,reg32		32	0F,A7		$1,$2		nil	386,UNDOC,OBS
loadall!twobyte		0F,07		386,UNDOC
loadall286!twobyte	0F,05		286,UNDOC
;pop	reg_cs			nil	0F		nil		nil	8086,UNDOC,OBS
salc!onebyte		nil,D6		8086,UNDOC
smi!onebyte		nil,F1		386,UNDOC
; opcode arbitrarily picked for next 3 (could be 12/13 instead of 10/11).
umov	reg8,reg8		nil	0F,10		$1r,$2		nil	386,UNDOC
umov	reg16,reg16		16	0F,11		$1r,$2		nil	386,UNDOC
umov	reg32,reg32		32	0F,11		$1r,$2		nil	386,UNDOC
umov	mem,reg8		nil	0F,10		$1,$2		nil	386,UNDOC
umov	mem8x,reg8		nil	0F,10		$1,$2		nil	386,UNDOC
umov	mem,reg16		16	0F,11		$1,$2		nil	386,UNDOC
umov	mem16x,reg16		16	0F,11		$1,$2		nil	386,UNDOC
umov	mem,reg32		32	0F,11		$1,$2		nil	386,UNDOC
umov	mem32x,reg32		32	0F,11		$1,$2		nil	386,UNDOC
umov	reg8,mem8		nil	0F,12		$2,$1		nil	386,UNDOC
umov	reg16,mem16		16	0F,13		$2,$1		nil	386,UNDOC
umov	reg32,mem32		32	0F,13		$2,$1		nil	386,UNDOC
xbts	reg16,mem16		16	0F,A6		$2,$1		nil	386,UNDOC,OBS
xbts	reg32,mem32		32	0F,A6		$2,$1		nil	386,UNDOC,OBS
