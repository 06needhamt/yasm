; $Id: instrs.dat,v 1.11 2001/07/04 08:03:04 peter Exp $
; List of valid instruction/operand combinations
;
;    Copyright (C) 2001  Peter Johnson
;
;    This file is part of YASM.
;
;    YASM is free software; you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation; either version 2 of the License, or
;    (at your option) any later version.
;
;    YASM is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program; if not, write to the Free Software
;    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
;
; Meanings of codes:
;  $x refers to operand x
;  "nil" in a field indicates the lack of that field in the instruction
;   (there MUST be some text in every field in this document)
;  Sizes are in bits (8,16,32 are the only valid quantities)
;
; Column definitions:
;  Inst     - Instruction, should be lowercase
;  Operands - Single combination of valid operands
;             "TO" is not counted in the operand count.
;  OpSize   - Fixed operand size.  Can generate prefix byte.
;  Opcode   - One or two bytes of opcode.
;  EffAddr  - Effective Address (ModRM/SIB/Off).  First value is the memory
;             operand, second specifies what value goes into the reg/spare
;             bits in the ModRM byte.
;             $xr indicates operand is register, not ModRM (needs convert to RM)
;             $xi indicates operand is immediate (2nd parm is size in bits)
;  Imm      - Immediate source operand and forced size (in bits).
;             $xr means relative displacement needed
;             "s" after size indicates signed number
;             A number instead of a $x is a hex constant value.
;
; A ':' at the beginning of the line means that the instruction following the
;  ':' is a synonym for the instruction in the 2nd column.
;
; See the parser file for a list of possible operand values and their meanings.
; gen_instr.pl translates this list into lexer and parser code.
;
; Instructions are listed in the order given by the "IA-32 Intel Architecture
;  Software Developer's Manual, Volume 2: Instruction Set Reference." Order
;  #245471.
;
; TODO:
;  Finish instructions (may require changing parser code).
;  Doublecheck instruction encodings, allowable operands.
;  Doublecheck CPU flags (especially on MMX/SSE/SSE2 opcodes).
;  Doublecheck AMD and Cyrix instructions.
;  Doublecheck the segreg mov instructions.
;
; !Grp	Operands		OpSize	Opcode		EffAddr		Imm	CPU
;
; Instruction Groupings (to shorten parser code).
;  The $0.1, $0.2, and $0.3 will get replaced with the parameters given for
;   the instruction using the group during lexing & parsing.  These parameters
;   may be in the opcode, effaddr, or immediate.
;  The first CPU grouping for the instruction is OR'ed with the CPU value in
;   the group CPU fields with #0 in their list.  This allows one grouping to
;   be used for instructions with different CPU values.
;  Restrictions on groupings:
;   - $0.? may not appear in the operand, the opsize, the first part of the
;     effaddr, the second part of the imm, or the CPU fields.
;   - #0, #1 may only appear in the CPU field.
;  Restrictions on instructions based on groupings:
;   - no other operand combinations are allowed (eg, if an instruction uses a
;     group, that must be the ONLY line for the instruction)
;
; Notes on code generation:
;  Each group generates a lex token of the group name (sans !).  Bison rules
;   are generated for each of the operand combinations for the group just as
;   with a regular instruction, except for the addition of the $0.? fields.
;   Each $0.? field is replaced by $1.d? in the generated code (eg,
;   $0.1->$1.d1, etc).
;  When an instruction that uses a group is encountered, eg:
;   inst!grpname  parm1[,parm2[,parm3]]
;  The following lex code is generated:
;   inst { yylval.groupdata.d1=0xparm1; return GRPNAME; }
;  (and additional yylval.groupdata.d#=0xparm#; if needed)
;
; Arithmetic instructions:
!arith	REG_AL,imm8		nil	$0.1+4		nil		$2,8	8086
!arith	REG_AX,imm16		16	$0.1+5		nil		$2,16	8086
!arith	REG_EAX,imm32		32	$0.1+5		nil		$2,32	386
!arith	reg8,imm		nil	80		$1r,$0.2	$2,8	8086
!arith	mem8x,imm		nil	80		$1,$0.2		$2,8	8086
!arith	reg8,imm8x		nil	80		$1r,$0.2	$2,8	8086
!arith	mem,imm8x		nil	80		$1,$0.2		$2,8	8086
!arith	reg16,imm		16	81		$1r,$0.2	$2,16	8086
!arith	mem16x,imm		16	81		$1,$0.2		$2,16	8086
!arith	reg16,imm16x		16	81		$1r,$0.2	$2,16	8086
!arith	mem,imm16x		16	81		$1,$0.2		$2,16	8086
!arith	reg32,imm		32	81		$1r,$0.2	$2,32	386
!arith	mem32x,imm		32	81		$1,$0.2		$2,32	386
!arith	reg32,imm32x		32	81		$1r,$0.2	$2,32	386
!arith	mem,imm32x		32	81		$1,$0.2		$2,32	386
!arith	reg16,imm8x		16	83		$1r,$0.2	$2,8s	8086
!arith	mem16x,imm8x		16	83		$1,$0.2		$2,8s	8086
!arith	reg32,imm8x		32	83		$1r,$0.2	$2,8s	386
!arith	mem32x,imm8x		32	83		$1,$0.2		$2,8s	386
; opcode arbitrarily picked for next 3 (could be $0.1+2/3 instead of $0.1+0/1).
!arith	reg8,reg8		nil	$0.1		$1r,$2		nil	8086
!arith	reg16,reg16		16	$0.1+1		$1r,$2		nil	8086
!arith	reg32,reg32		32	$0.1+1		$1r,$2		nil	386
!arith	mem,reg8		nil	$0.1		$1,$2		nil	8086
!arith	mem8x,reg8		nil	$0.1		$1,$2		nil	8086
!arith	mem,reg16		16	$0.1+1		$1,$2		nil	8086
!arith	mem16x,reg16		16	$0.1+1		$1,$2		nil	8086
!arith	mem,reg32		32	$0.1+1		$1,$2		nil	386
!arith	mem32x,reg32		32	$0.1+1		$1,$2		nil	386
!arith	reg8,mem8		nil	$0.1+2		$2,$1		nil	8086
!arith	reg16,mem16		16	$0.1+3		$2,$1		nil	8086
!arith	reg32,mem32		32	$0.1+3		$2,$1		nil	386
;
; Bit Test (BT/BTC/BTR/BTS) group:
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!bittest	reg16,reg16	16	0F,$0.1		$1r,$2		nil	386
!bittest	mem,reg16	16	0F,$0.1		$1,$2		nil	386
!bittest	mem16x,reg16	16	0F,$0.1		$1,$2		nil	386
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!bittest	reg32,reg32	32	0F,$0.1		$1r,$2		nil	386
!bittest	mem,reg32	32	0F,$0.1		$1,$2		nil	386
!bittest	mem32x,reg32	32	0F,$0.1		$1,$2		nil	386
!bittest	reg16,imm8	16	0F,BA		$1r,$0.2	$2,8	386
!bittest	mem16x,imm8	16	0F,BA		$1,$0.2		$2,8	386
!bittest	reg32,imm8	32	0F,BA		$1r,$0.2	$2,8	386
!bittest	mem32x,imm8	32	0F,BA		$1,$0.2		$2,8	386
;
; BSF/BSR:
!bsfr	reg16,rm16		16	0F,BC+$0.1	$2,$1		nil	386
!bsfr	reg32,rm32		32	0F,BC+$0.1	$2,$1		nil	386
;
; CMPXCHG/XADD:
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!cmpxchgxadd	reg8,reg8		nil	0F,$0.1		$1r,$2	nil	486
!cmpxchgxadd	mem,reg8		nil	0F,$0.1		$1,$2	nil	486
!cmpxchgxadd	mem8x,reg8		nil	0F,$0.1		$1,$2	nil	486
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!cmpxchgxadd	reg16,reg16		16	0F,$0.1+1	$1r,$2	nil	486
!cmpxchgxadd	mem,reg16		16	0F,$0.1+1	$1,$2	nil	486
!cmpxchgxadd	mem16x,reg16		16	0F,$0.1+1	$1,$2	nil	486
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!cmpxchgxadd	reg32,reg32		32	0F,$0.1+1	$1r,$2	nil	486
!cmpxchgxadd	mem,reg32		32	0F,$0.1+1	$1,$2	nil	486
!cmpxchgxadd	mem32x,reg32		32	0F,$0.1+1	$1,$2	nil	486
;
; Cyrix MMX instructions:
!cyrixmmx	MMXREG,rm64	nil	0F,$0.1		$2,$1		nil	P5,MMX,CYRIX
;
; Cyrix System Manaagement Mode instructions:
!cyrixsmm	mem80		nil	0F,$0.1		$1,0		nil	486,CYRIX,SMM
;
; FPU reversible arithmetic instructions (with TO):
!farith	mem32x			nil	D8		$1,$0.1		nil	8086,FPU
!farith	mem64x			nil	DC		$1,$0.1		nil	8086,FPU
!farith	fpureg			nil	D8,$0.2+$1	nil		nil	8086,FPU
!farith	ST0,ST0			nil	D8,$0.2		nil		nil	8086,FPU
!farith	ST0,FPUREG_NOTST0	nil	D8,$0.2+$2	nil		nil	8086,FPU
!farith	TO fpureg		nil	DC,$0.3+$1	nil		nil	8086,FPU
!farith	FPUREG_NOTST0,ST0	nil	DC,$0.3+$1	nil		nil	8086,FPU
!farithp	fpureg		nil	DE,$0.1+$1	nil		nil	8086,FPU
!farithp	fpureg,ST0	nil	DE,$0.1+$1	nil		nil	8086,FPU
;
; FPU compare group 1 (FCOM/FCOMP):
!fcomg	mem32x			nil	D8		$1,$0.1		nil	8086,FPU
!fcomg	mem64x			nil	DC		$1,$0.1		nil	8086,FPU
!fcomg	fpureg			nil	D8,$0.2+$1	nil		nil	8086,FPU
!fcomg	ST0,fpureg		nil	D8,$0.2+$2	nil		nil	8086,FPU
;
; FPU compare group 2 (FCOMI/FCOMIP/FUCOMI/FUCOMIP/FUCOM/FUCOMP):
!fcomg2	fpureg			nil	$0.1,$0.2+$1	nil		nil	8086,FPU
!fcomg2	ST0,fpureg		nil	$0.1,$0.2+$2	nil		nil	8086,FPU
;
; FPU integer arithmetic instructions:
!fiarith	mem32x		nil	DA		$1,$0.1		nil	8086,FPU
!fiarith	mem16x		nil	DE		$1,$0.1		nil	8086,FPU
;
; "F6" opcode group (DIV/IDIV/MUL/NEG/NOT):
!groupf6	rm8x		nil	F6		$1,$0.1		nil	8086
!groupf6	rm16x		16	F7		$1,$0.1		nil	8086
!groupf6	rm32x		32	F7		$1,$0.1		nil	386
;
; INC/DEC:
!incdec	rm8x			nil	FE		$1,$0.1		nil	8086
!incdec	mem16x			16	FF		$1,$0.1		nil	8086
!incdec	mem32x			32	FF		$1,$0.1		nil	386
!incdec	reg16			16	$0.2+$1		nil		nil	8086
!incdec	reg32			32	$0.2+$1		nil		nil	386
;
; Extension moves (MOVSX/MOVZX):
!movszx	reg16,rm8		16	0F,$0.1		$2,$1		nil	386
!movszx	reg32,rm8x		32	0F,$0.1		$2,$1		nil	386
!movszx	reg32,rm16x		nil	0F,$0.1+1	$2,$1		nil	386
;
; AMD 3DNow! general instructions:
!now3d	MMXREG,rm64		nil	0F,0F		$2,$1		$0.1,8	#0,3DNOW,AMD
;
; One byte opcode instructions with no operands:
!onebyte	nil		nil 	$0.1		nil		nil	#0
!onebyte16	nil		16	$0.1		nil		nil	8086
!onebyte32	nil		32	$0.1		nil		nil	386
;
; 286 rm16 protected mode group (LLDT/LTR/STR/VERR/VERW):
!prot286	rm16		nil	0F,00		$1,$0.1		nil	286,PROT,#0
;
; MMX/SSE2 shifts (PSLLW/PSLLD/PSLLQ/PSRAW/PSRAD/PSRLW/PSRLD/PSRLQ):
!pshift	MMXREG,rm64		nil	0F,$0.1		$2,$1		nil	P5,MMX
!pshift	XMMREG,rm128		nil	66,0F,$0.1	$2,$1		nil	P4,SSE2
!pshift	MMXREG,imm8		nil	0F,$0.2		$1r,$0.3	$2,8	P5,MMX
!pshift	XMMREG,imm8		nil	66,0F,$0.2	$1r,$0.3	$2,8	P4,SSE2
;
; Shift instructions (RCL/RCR/ROL/ROR/SAL/SAR/SHL/SHR):
!shift	rm8x,ONE		nil	D0		$1,$0.1		nil	8086
!shift	rm8x,REG_CL		nil	D2		$1,$0.1		nil	8086
!shift	rm8x,imm8		nil	C0		$1,$0.1		$2,8	186
!shift	rm16x,ONE		16	D1		$1,$0.1		nil	8086
!shift	rm16x,REG_CL		16	D3		$1,$0.1		nil	8086
!shift	rm16x,imm8		16	C1		$1,$0.1		$2,8	186
!shift	rm32x,ONE		32	D1		$1,$0.1		nil	386
!shift	rm32x,REG_CL		32	D3		$1,$0.1		nil	386
!shift	rm32x,imm8		32	C1		$1,$0.1		$2,8	386
;
; Doubleword shifts (SHLD/SHRD):
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!shlrd	reg16,reg16,imm8	16	0F,$0.1		$1r,$2		$3,8	386
!shlrd	mem,reg16,imm8		16	0F,$0.1		$1,$2		$3,8	386
!shlrd	mem16x,reg16,imm8	16	0F,$0.1		$1,$2		$3,8	386
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!shlrd	reg16,reg16,REG_CL	16	0F,$0.1+1	$1r,$2		nil	386
!shlrd	mem,reg16,REG_CL	16	0F,$0.1+1	$1,$2		nil	386
!shlrd	mem16x,reg16,REG_CL	16	0F,$0.1+1	$1,$2		nil	386
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!shlrd	reg32,reg32,imm8	32	0F,$0.1		$1r,$2		$3,8	386
!shlrd	mem,reg32,imm8		32	0F,$0.1		$1,$2		$3,8	386
!shlrd	mem32x,reg32,imm8	32	0F,$0.1		$1,$2		$3,8	386
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
!shlrd	reg32,reg32,REG_CL	32	0F,$0.1+1	$1r,$2		nil	386
!shlrd	mem,reg32,REG_CL	32	0F,$0.1+1	$1,$2		nil	386
!shlrd	mem32x,reg32,REG_CL	32	0F,$0.1+1	$1,$2		nil	386
;
; SSE/SSE2 standard variations:
!sse2pd	XMMREG,rm128		nil	66,0F,$0.1	$2,$1		nil	P4,SSE2
!sseps	XMMREG,rm128		nil	0F,$0.1		$2,$1		nil	#0
!sse2sd	XMMREG,rm128		nil	F2,0F,$0.1	$2,$1		nil	P4,SSE2
!sse2ss	XMMREG,rm128		nil	F3,0F,$0.1	$2,$1		nil	P4,SSE2
;
; SSE/SSE2 standard variations, with immediate:
!sse2pdimm	XMMREG,rm128,imm8	nil	66,0F,$0.1	$2,$1	$3,8	P4,SSE2
!ssepsimm	XMMREG,rm128,imm8	nil	0F,$0.1		$2,$1	$3,8	KATMAI,SSE
;
; SSE/SSE2 and MMX shared instructions:
!mmxsse	MMXREG,rm64		nil	0F,$0.1		$2,$1		nil	#0,MMX
!mmxsse	XMMREG,rm128		nil	66,0F,$0.1	$2,$1		nil	#1
;
; Two byte opcode instructions with no operands:
!twobyte	nil		nil	$0.1,$0.2	nil		nil	#0
;
; Three byte opcode instructions with no operands:
!threebyte	nil		nil	$0.1,$0.2,$0.3	nil		nil	#0
;
;
; Instruction Lines:
; Inst	Operands		OpSize	Opcode		EffAddr	Imm	CPU
;  *or*
; Inst!Group		Parameters	CPU #0
aaa!onebyte		37		8086
aad	nil			nil	D5,0A		nil	nil	8086
aad	imm8			nil	D5		nil	$1,8	8086
aam	nil			nil	D4,0A		nil	nil	8086
aam	imm8			nil	D4		nil	$1,8	8086
aas!onebyte		3F		8086
adc!arith		10,2
add!arith		00,0
addpd!sse2pd		58
addps!sseps		58		KATMAI,SSE
addsd!sse2sd		58
addss!sse2ss		58
and!arith		20,4
andpd!sse2pd		54
andps!sseps		54		P4,SSE2
andnpd!sse2pd		55
andnps!sseps		55		P4,SSE2
arpl	rm16,reg16		nil	63		$1,$2	nil	286,PROT
bound	reg16,mem16		16	62		$2,$1	nil	186
bound	reg32,mem32		32	62		$2,$1	nil	386
bsf!bsfr		0
bsr!bsfr		1
bswap	reg32			32	0F,C8+$1	nil	nil	486
bt!bittest		A3,4
btc!bittest		BB,7
btr!bittest		B3,6
bts!bittest		AB,5
; call
cbw!onebyte16		98
cwde!onebyte32		98
clc!onebyte		F8		8086
cld!onebyte		FC		8086
clflush	mem8			nil	0F,AE		$1,7	nil	KATMAI
cli!onebyte		FA		8086
clts!twobyte		0F,06		286,PRIV
cmc!onebyte		F5		8086
; cmov
cmp!arith		38,7
cmppd!sse2pdimm		C2
cmpps!ssepsimm		C2
cmpsb!onebyte		A6		8086
cmpsw!onebyte16		A7
cmpsd	nil			32	A7		nil	nil	386
cmpsd	XMMREG,rm128,imm8	nil	F2,0F,C2	$2,$1	$3,8	P4,SSE2
cmpss	XMMREG,rm128,imm8	nil	F3,0F,C2	$2,$1	$3,8	P4,SSE2
cmpxchg!cmpxchgxadd	B0
cmpxchg8b	mem64		nil	0F,C7		$1,1	nil	P5
comisd!sse2pd		2F
comiss!sseps		2F		KATMAI,SSE
cpuid!twobyte		0F,A2		P5
cvtdq2pd!sse2ss		E6
cvtdq2ps!sseps		5B		P4,SSE2
cvtpd2dq!sse2sd		E6
cvtpd2pi!sse2pd		2D
cvtpd2ps!sse2pd		5A
cvtpi2pd!sse2pd		2A
cvtpi2ps!sseps		2A		P4,SSE2
cvtps2dq!sse2pd		5B
cvtps2pd!sseps		5A		P4,SSE2
cvtps2pi!sseps		2D		P4,SSE2
cvtsd2si!sse2sd		2D
cvtsd2ss!sse2sd		5A
cvtsi2sd!sse2sd		2A
cvtsi2ss!sse2ss		2A
cvtss2sd!sse2ss		5A
cvtss2si!sse2ss		2D
cvttpd2pi!sse2pd	2C
cvttpd2dq!sse2pd	E6
cvttps2dq!sse2ss	5B
cvttps2pi!sseps		2C		P4,SSE2
cvttsd2si!sse2sd	2C
cvttss2si!sse2ss	2C
cwd!onebyte16		99
cdq!onebyte32		99
daa!onebyte		27		8086
das!onebyte		2F		8086
dec!incdec		1,48
div!groupf6		6
divpd!sse2pd		5E
divps!sseps		5E		KATMAI,SSE
divsd!sse2sd		5E
divss!sse2ss		5E
emms!twobyte		0F,77		P5,MMX
enter	imm16,imm8		nil	C8		$1i,16	$2,8	186
f2xm1!twobyte		D9,F0		8086,FPU
fabs!twobyte		D9,E1		8086,FPU
fadd!farith		0,C0,C0
faddp!farithp		C0
fiadd!fiarith		0
fbld	mem80			nil	DF		$1,4	nil	8086,FPU
fbstp	mem80			nil	DF		$1,6	nil	8086,FPU
fchs!twobyte		D9,E0		8086,FPU
fclex!threebyte		9B,DB,E2	8086,FPU
fnclex!twobyte		DB,E2		8086,FPU
; fcmov
fcom!fcomg		2,D0
fcomp!fcomg		3,D8
fcompp!twobyte		DE,D9		8086,FPU
fcomi!fcomg2		DB,F0
fcomip!fcomg2		DF,F0
fucomi!fcomg2		DB,E8
fucomip!fcomg2		DF,E8
fcos!twobyte		D9,FF		8086,FPU
fdecstp!twobyte		D9,F6		8086,FPU
fdiv!farith		6,F0,F8
fdivp!farithp		F8
fidiv!fiarith		6
fdivr!farith		7,F8,F0
fdivrp!farithp		F0
fidivr!fiarith		7
ffree	fpureg			nil	DD,C0+$1	nil	nil	8086,FPU
ficom	mem16x			nil	DE		$1,2	nil	8086,FPU
ficom	mem32x			nil	DA		$1,2	nil	8086,FPU
ficomp	mem16x			nil	DE		$1,3	nil	8086,FPU
ficomp	mem32x			nil	DA		$1,3	nil	8086,FPU
fild	mem16x			nil	DF		$1,0	nil	8086,FPU
fild	mem32x			nil	DB		$1,0	nil	8086,FPU
fild	mem64x			nil	DF		$1,5	nil	8086,FPU
fincstp!twobyte		D9,F7		8086,FPU
finit!threebyte		9B,DB,E3	8086,FPU
fninit!twobyte		DB,E3		8086,FPU
fist	mem16x			nil	DF		$1,2	nil	8086,FPU
fist	mem32x			nil	DB		$1,2	nil	8086,FPU
fistp	mem16x			nil	DF		$1,3	nil	8086,FPU
fistp	mem32x			nil	DB		$1,3	nil	8086,FPU
fistp	mem64x			nil	DF		$1,7	nil	8086,FPU
fld	mem32x			nil	D9		$1,0	nil	8086,FPU
fld	mem64x			nil	DD		$1,0	nil	8086,FPU
fld	mem80x			nil	DB		$1,5	nil	8086,FPU
fld	fpureg			nil	D9,C0+$1	nil	nil	8086,FPU
fld1!twobyte		D9,E8		8086,FPU
fldl2t!twobyte		D9,E9		8086,FPU
fldl2e!twobyte		D9,EA		8086,FPU
fldpi!twobyte		D9,EB		8086,FPU
fldlg2!twobyte		D9,EC		8086,FPU
fldln2!twobyte		D9,ED		8086,FPU
fldz!twobyte		D9,EE		8086,FPU
fldcw	mem16			nil	D9		$1,5	nil	8086,FPU
fldenv	mem			nil	D9		$1,4	nil	8086,FPU
fmul!farith		1,C8,C8
fmulp!farithp		C8
fimul!fiarith		1
fnop!twobyte		D9,D0		8086,FPU
fpatan!twobyte		D9,F3		8086,FPU
fprem!twobyte		D9,F8		8086,FPU
fprem1!twobyte		D9,F5		8086,FPU
fptan!twobyte		D9,F2		8086,FPU
frndint!twobyte		D9,FC		8086,FPU
frstor	mem			nil	DD		$1,4	nil	8086,FPU
fsave	mem			nil	9B,DD		$1,6	nil	8086,FPU
fnsave	mem			nil	DD		$1,6	nil	8086,FPU
fscale!twobyte		D9,FD		8086,FPU
fsin!twobyte		D9,FE		8086,FPU
fsincos!twobyte		D9,FB		8086,FPU
fsqrt!twobyte		D9,FA		8086,FPU
fst	mem32x			nil	D9		$1,2	nil	8086,FPU
fst	mem64x			nil	DD		$1,2	nil	8086,FPU
fst	fpureg			nil	DD,D0+$1	nil	nil	8086,FPU
fstp	mem32x			nil	D9		$1,3	nil	8086,FPU
fstp	mem64x			nil	DD		$1,3	nil	8086,FPU
fstp	mem80x			nil	DB		$1,7	nil	8086,FPU
fstp	fpureg			nil	DD,D8+$1	nil	nil	8086,FPU
fstcw	mem16			nil	9B,D9		$1,7	nil	8086,FPU
fnstcw	mem16			nil	D9		$1,7	nil	8086,FPU
fstenv	mem			nil	9B,D9		$1,6	nil	8086,FPU
fnstenv	mem			nil	D9		$1,6	nil	8086,FPU
fstsw	mem16			nil	9B,DD		$1,7	nil	8086,FPU
fstsw	REG_AX			nil	9B,DF,E0	nil	nil	8086,FPU
fnstsw	mem16			nil	DD		$1,7	nil	8086,FPU
fnstsw	REG_AX			nil	DF,E0		nil	nil	8086,FPU
fsub!farith		4,E0,E8
fsubp!farithp		E8
fisub!fiarith		4
fsubr!farith		5,E8,E0
fsubrp!farithp		E0
fisubr!fiarith		5
ftst!twobyte		D9,E4		8086,FPU
fucom!fcomg2		DD,E0
fucomp!fcomg2		DD,E8
fucompp!twobyte		DA,E9		8086,FPU
fxam!twobyte		D9,E5		8086,FPU
fxch	fpureg			nil	D9,C8+$1	nil	nil	8086,FPU
fxch	ST0,ST0			nil	D9,C8		nil	nil	8086,FPU
fxch	ST0,FPUREG_NOTST0	nil	D9,C8+$2	nil	nil	8086,FPU
fxch	FPUREG_NOTST0,ST0	nil	D9,C8+$1	nil	nil	8086,FPU
fxch	nil			nil	D9,C9		nil	nil	8086,FPU
fxrstor	mem			nil	0F,AE		$1,1	nil	P6,SSE,FPU
fxsave	mem			nil	0F,AE		$1,0	nil	P6,SSE,FPU
fxtract!twobyte		D9,F4		8086,FPU
fyl2x!twobyte		D9,F1		8086,FPU
fyl2xp1!twobyte		D9,F9		8086,FPU
hlt!onebyte		F4		8086,PRIV
idiv!groupf6		7
imul	rm8x			nil	F6		$1,5	nil	8086
imul	rm16x			16	F7		$1,5	nil	8086
imul	rm32x			32	F7		$1,5	nil	386
imul	reg16,rm16		16	0F,AF		$2,$1	nil	386
imul	reg32,rm32		32	0F,AF		$2,$1	nil	386
imul	reg16,rm16,imm8x	16	6B		$2,$1	$3,8s	186
imul	reg32,rm32,imm8x	32	6B		$2,$1	$3,8s	386
imul	reg16,imm8x		16	6B		$1r,$1	$2,8s	186
imul	reg32,imm8x		32	6B		$1r,$1	$2,8s	386
imul	reg16,rm16,imm16	16	69		$2,$1	$3,16s	186
imul	reg32,rm32,imm32	32	69		$2,$1	$3,32s	386
imul	reg16,imm16		16	69		$1r,$1	$2,16s	186
imul	reg32,imm32		32	69		$1r,$1	$2,32s	386
in	REG_AL,imm8		nil	E4		nil	$2,8	8086
in	REG_AX,imm8		16	E5		nil	$2,8	8086
in	REG_EAX,imm8		32	E5		nil	$2,8	386
in	REG_AL,REG_DX		nil	EC		nil	nil	8086
in	REG_AX,REG_DX		16	ED		nil	nil	8086
in	REG_EAX,REG_DX		32	ED		nil	nil	386
inc!incdec		0,40
insb!onebyte		6C		8086
insw!onebyte16		6D
insd!onebyte32		6D
int3!onebyte		CC		8086
int03!onebyte		CC		8086
int	imm8			nil	CD		nil	$1,8	8086
into!onebyte		CE		8086
invd!twobyte		0F,08		486,PRIV
invlpg	mem			nil	0F,01		$1,7	nil	486,PRIV
iret!onebyte		CF		8086
iretw!onebyte16		CF
iretd!onebyte32		CF
; jcc
; jmp
lahf!onebyte		9F		8086
lar	reg16,rm16		16	0F,02		$2,$1	nil	286,PROT
lar	reg32,rm32		32	0F,02		$2,$1	nil	386,PROT
ldmxcsr	mem32			nil	0F,AE		$1,2	nil	KATMAI,SSE
lds	reg16,mem		16	C5		$2,$1	nil	8086
lds	reg32,mem		32	C5		$2,$1	nil	386
lss	reg16,mem		16	0F,B2		$2,$1	nil	386
lss	reg32,mem		32	0F,B2		$2,$1	nil	386
les	reg16,mem		16	C4		$2,$1	nil	8086
les	reg32,mem		32	C4		$2,$1	nil	386
lfs	reg16,mem		16	0F,B4		$2,$1	nil	386
lfs	reg32,mem		32	0F,B4		$2,$1	nil	386
lgs	reg16,mem		16	0F,B5		$2,$1	nil	386
lgs	reg32,mem		32	0F,B5		$2,$1	nil	386
lea	reg16,mem16		16	8D		$2,$1	nil	8086
lea	reg32,mem32		32	8D		$2,$1	nil	386
leave!onebyte		C9		186
; lfence
lgdt	mem			nil	0F,01		$1,2	nil	286,PRIV
lidt	mem			nil	0F,01		$1,3	nil	286,PRIV
lldt!prot286		2		PRIV
lmsw	rm16			nil	0F,01		$1,6	nil	286,PRIV
lodsb!onebyte		AC		8086
lodsw!onebyte16		AD
lodsd!onebyte32		AD
; loop
; loopcc:
;:loope	loopz
;loopz	imm1632			nil	E1		nil	$1r,8s	8086
;loopz	imm1632,REG_CX		16	E1		nil	$1r,8s	8086
;loopz	imm1632,REG_ECX		32	E1		nil	$1r,8s	386
;:loopne	loopnz
;loopnz	imm1632			nil	E1		nil	$1r,8s	8086
;loopnz	imm1632,REG_CX		16	E1		nil	$1r,8s	8086
;loopnz	imm1632,REG_ECX		32	E1		nil	$1r,8s	386
lsl	reg16,rm16		16	0F,03		$2,$1	nil	286,PROT
lsl	reg32,rm32		32	0F,03		$2,$1	nil	286,PROT
ltr!prot286		3		PRIV
maskmovdqu	XMMREG,XMMREG	nil	66,0F,F7	$2r,$1	nil	P4,SSE2
maskmovq	MMXREG,MMXREG	nil	0F,F7		$2r,$1	nil	KATMAI,MMX
maxpd!sse2pd		5F
maxps!sseps		5F		KATMAI,SSE
maxsd!sse2sd		5F
maxss!sse2ss		5F
; opcode arbitrarily picked for next 3 (could be 8A/8B instead of 88/89).
mov	reg8,reg8		nil	88		$1r,$2	nil	8086
mov	reg16,reg16		16	89		$1r,$2	nil	8086
mov	reg32,reg32		32	89		$1r,$2	nil	386
mov	mem,reg8		nil	88		$1,$2	nil	8086
mov	mem8x,reg8		nil	88		$1,$2	nil	8086
mov	mem,reg16		16	89		$1,$2	nil	8086
mov	mem16x,reg16		16	89		$1,$2	nil	8086
mov	mem,reg32		32	89		$1,$2	nil	386
mov	mem32x,reg32		32	89		$1,$2	nil	386
mov	reg8,mem8		nil	8A		$2,$1	nil	8086
mov	reg16,mem16		16	8B		$2,$1	nil	8086
mov	reg32,mem32		32	8B		$2,$1	nil	386
mov	mem,segreg		nil	8C		$1,$2	nil	8086
mov	reg16,segreg		16	8C		$1r,$2	nil	8086
mov	mem16x,segreg		16	8C		$1,$2	nil	8086
mov	reg32,segreg		32	8C		$1r,$2	nil	386
mov	mem32x,segreg		32	8C		$1,$2	nil	386
mov	segreg,mem		nil	8E		$2,$1	nil	8086
mov	segreg,rm16x		nil	8E		$2,$1	nil	8086
mov	segreg,rm32x		nil	8E		$2,$1	nil	386
;mov	REG_AL,memoff8
;mov	REG_AX,memoff16
;mov	REG_EAX,memoff32
;mov	memoff8,REG_AL
;mov	memoff16,REG_AX
;mov	memoff32,REG_EAX
mov	reg8,imm8		nil	B0+$1		nil	$2,8	8086
mov	reg16,imm16		16	B8+$1		nil	$2,16	8086
mov	reg32,imm32		32	B8+$1		nil	$2,32	386
mov	mem8x,imm8		nil	C6		$1,0	$2,8	8086
mov	mem,imm8x		nil	C6		$1,0	$2,8	8086
mov	mem16x,imm16		16	C7		$1,0	$2,16	8086
mov	mem,imm16x		16	C7		$1,0	$2,16	8086
mov	mem32x,imm32		32	C7		$1,0	$2,32	8086
mov	mem,imm32x		32	C7		$1,0	$2,32	8086
mov	CRREG_NOTCR4,reg32	nil	0F,22		$2r,$1	nil	386,PRIV
mov	CR4,reg32		nil	0F,22		$2r,$1	nil	P5,PRIV
mov	reg32,CRREG_NOTCR4	nil	0F,20		$1r,$2	nil	386,PRIV
mov	reg32,CR4		nil	0F,20		$1r,$2	nil	P5,PRIV
mov	reg32,DRREG		nil	0F,21		$1r,$2	nil	386,PRIV
mov	DRREG,reg32		nil	0F,23		$2r,$1	nil	386,PRIV
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movapd	XMMREG,XMMREG		nil	66,0F,28	$2r,$1	nil	P4,SSE2
movapd	XMMREG,mem128		nil	66,0F,28	$2,$1	nil	P4,SSE2
movapd	mem128,XMMREG		nil	66,0F,29	$1,$2	nil	P4,SSE2
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movaps	XMMREG,XMMREG		nil	0F,28		$2r,$1	nil	KATMAI,SSE
movaps	XMMREG,mem128		nil	0F,28		$2,$1	nil	KATMAI,SSE
movaps	mem128,XMMREG		nil	0F,29		$1,$2	nil	KATMAI,SSE
movd	MMXREG,rm32		nil	0F,6E		$2,$1	nil	P5,MMX
movd	rm32,MMXREG		nil	0F,7E		$1,$2	nil	P5,MMX
movd	XMMREG,rm32		nil	66,0F,6E	$2,$1	nil	P4,SSE2
movd	rm32,XMMREG		nil	66,0F,7E	$1,$2	nil	P4,SSE2
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movdqa	XMMREG,XMMREG		nil	66,0F,6F	$2r,$1	nil	P4,SSE2
movdqa	XMMREG,mem128		nil	66,0F,6F	$2,$1	nil	P4,SSE2
movdqa	mem128,XMMREG		nil	66,0F,7F	$1,$2	nil	P4,SSE2
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movdqu	XMMREG,XMMREG		nil	F3,0F,6F	$2r,$1	nil	P4,SSE2
movdqu	XMMREG,mem128		nil	F3,0F,6F	$2,$1	nil	P4,SSE2
movdqu	mem128,XMMREG		nil	F3,0F,7F	$1,$2	nil	P4,SSE2
; TODO: not sure if this encoding (movdq2q) is correct
movdq2q	MMXREG,XMMREG		nil	F2,0F,D6	$1r,$2	nil	P4,SSE2
movhlps	XMMREG,XMMREG		nil	0F,12		$2r,$1	nil	KATMAI,SSE
movhpd	XMMREG,mem64		nil	66,0F,16	$2,$1	nil	P4,SSE2
movhpd	mem64,XMMREG		nil	66,0F,17	$1,$2	nil	P4,SSE2
movhps	XMMREG,mem64		nil	0F,16		$2,$1	nil	KATMAI,SSE
movhps	mem64,XMMREG		nil	0F,17		$1,$2	nil	KATMAI,SSE
movlhps	XMMREG,XMMREG		nil	0F,16		$2r,$1	nil	KATMAI,SSE
movlpd	XMMREG,mem64		nil	66,0F,12	$2,$1	nil	P4,SSE2
movlpd	mem64,XMMREG		nil	66,0F,13	$1,$2	nil	P4,SSE2
movlps	XMMREG,mem64		nil	0F,12		$2,$1	nil	KATMAI,SSE
movlps	mem64,XMMREG		nil	0F,13		$1,$2	nil	KATMAI,SSE
movmskpd	reg32,XMMREG	nil	66,0F,50	$1r,$2	nil	P4,SSE2
movmskps	reg32,XMMREG	nil	0F,50		$1r,$2	nil	KATMAI,SSE
movntdq	mem128,XMMREG		nil	66,0F,E7	$1,$2	nil	P4,SSE2
movnti	mem32,reg32		nil	0F,C3		$1,$2	nil	P4
movntpd	mem128,XMMREG		nil	66,0F,2B	$1,$2	nil	P4,SSE2
movntps	mem128,XMMREG		nil	0F,2B		$1,$2	nil	KATMAI,SSE
movntq	mem64,MMXREG		nil	0F,E7		$1,$2	nil	KATMAI,MMX
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movq	MMXREG,MMXREG		nil	0F,6F		$2r,$1	nil	P5,MMX
movq	MMXREG,mem64		nil	0F,6F		$2,$1	nil	P5,MMX
movq	mem64,MMXREG		nil	0F,7F		$1,$2	nil	P5,MMX
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movq	XMMREG,XMMREG		nil	F3,0F,7E	$2r,$1	nil	P4,SSE2
movq	XMMREG,mem64		nil	F3,0F,7E	$2,$1	nil	P4,SSE2
movq	mem64,XMMREG		nil	66,0F,D6	$1,$2	nil	P4,SSE2
; TODO: not sure if this encoding (movq2dq) is correct
movq2dq	XMMREG,MMXREG		nil	F3,0F,D6	$1r,$2	nil	P4,SSE2
movsb!onebyte		A4		8086
movsw!onebyte16		A5
movsd	nil			32	A5		nil	nil	386
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movsd	XMMREG,XMMREG		nil	F2,0F,10	$2r,$1	nil	P4,SSE2
movsd	XMMREG,mem64		nil	F2,0F,10	$2,$1	nil	P4,SSE2
movsd	mem64,XMMREG		nil	F2,0F,11	$1,$2	nil	P4,SSE2
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movss	XMMREG,XMMREG		nil	F3,0F,10	$2r,$1	nil	P4,SSE2
movss	XMMREG,mem64		nil	F3,0F,10	$2,$1	nil	P4,SSE2
movss	mem64,XMMREG		nil	F3,0F,11	$1,$2	nil	P4,SSE2
movsx!movszx		BE
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movupd	XMMREG,XMMREG		nil	66,0F,10	$2r,$1	nil	P4,SSE2
movupd	XMMREG,mem64		nil	66,0F,10	$2,$1	nil	P4,SSE2
movupd	mem64,XMMREG		nil	66,0F,11	$1,$2	nil	P4,SSE2
; arbitrary encoding, picked $2r,$1 instead of $1r,$2
movups	XMMREG,XMMREG		nil	0F,10		$2r,$1	nil	P4,SSE2
movups	XMMREG,mem64		nil	0F,10		$2,$1	nil	P4,SSE2
movups	mem64,XMMREG		nil	0F,11		$1,$2	nil	P4,SSE2
movzx!movszx		B6
mul!groupf6		4
mulpd!sse2pd		59
mulps!sseps		59		KATMAI,SSE
mulsd!sse2sd		59
mulss!sse2ss		59
neg!groupf6		3
nop!onebyte		90		8086
not!groupf6		2
or!arith		08,1
orpd!sse2pd		56
orps!sseps		56		KATMAI,SSE
out	imm8,REG_AL		nil	E6		nil	$1,8	8086
out	imm8,REG_AX		16	E7		nil	$1,8	8086
out	imm8,REG_EAX		32	E7		nil	$1,8	386
out	REG_DX,REG_AL		nil	EE		nil	nil	8086
out	REG_DX,REG_AX		16	EF		nil	nil	8086
out	REG_DX,REG_EAX		32	EF		nil	nil	386
outsb!onebyte		6E		8086
outsw!onebyte16		6F
outsd!onebyte32		6F
packsswb!mmxsse		63		P5		P4,SSE2
packssdw!mmxsse		6B		P5		P4,SSE2
packuswb!mmxsse		67		P5		P4,SSE2
paddb!mmxsse		FC		P5		P4,SSE2
paddw!mmxsse		FD		P5		P4,SSE2
paddd!mmxsse		FE		P5		P4,SSE2
paddq!mmxsse		D4		P5		P4,SSE2
paddsb!mmxsse		EC		P5		P4,SSE2
paddsw!mmxsse		ED		P5		P4,SSE2
paddusb!mmxsse		DC		P5		P4,SSE2
paddusw!mmxsse		DD		P5		P4,SSE2
pand!mmxsse		DB		P5		P4,SSE2
pandn!mmxsse		DF		P5		P4,SSE2
pause!twobyte		F3,90		P4
pavgb!mmxsse		E0		KATMAI		P4,SSE2
pavgw!mmxsse		E3		KATMAI		P4,SSE2
pcmpeqb!mmxsse		74		P5		P4,SSE2
pcmpeqw!mmxsse		75		P5		P4,SSE2
pcmpeqd!mmxsse		76		P5		P4,SSE2
pcmpgtb!mmxsse		64		P5		P4,SSE2
pcmpgtw!mmxsse		65		P5		P4,SSE2
pcmpgtd!mmxsse		66		P5		P4,SSE2
pextrw	reg32,MMXREG,imm8	nil	0F,C5		$1r,$2	$3,8	KATMAI,MMX
pextrw	reg32,XMMREG,imm8	nil	66,0F,C5	$1r,$2	$3,8	P4,SSE2
pinsrw	MMXREG,reg32,imm8	nil	0F,C4		$2r,$1	$3,8	KATMAI,MMX
pinsrw	MMXREG,rm16,imm8	nil	0F,C4		$2,$1	$3,8	KATMAI,MMX
pinsrw	XMMREG,reg32,imm8	nil	66,0F,C4	$2r,$1	$3,8	P4,SSE2
pinsrw	XMMREG,rm16,imm8	nil	66,0F,C4	$2,$1	$3,8	P4,SSE2
pmaddwd!mmxsse		F5		P5		P4,SSE2
pmaxsw!mmxsse		EE		KATMAI		P4,SSE2
pmaxub!mmxsse		DE		KATMAI		P4,SSE2
pminsw!mmxsse		EA		KATMAI		P4,SSE2
pminub!mmxsse		DA		KATMAI		P4,SSE2
pmovmskb	reg32,MMXREG	nil	0F,D7		$1r,$2	nil	KATMAI,MMX
pmovmskb	reg32,XMMREG	nil	66,0F,D7	$1r,$2	nil	P4,SSE2
pmulhuw!mmxsse		E4		KATMAI		P4,SSE2
pmulhw!mmxsse		E5		P5		P4,SSE2
pmullw!mmxsse		D5		P5		P4,SSE2
pmuludq!mmxsse		F4		P4		P4,SSE2
pop	mem16x			16	8F		$1,0	nil	8086
pop	mem32x			32	8F		$1,0	nil	386
pop	reg16			16	58+$1		nil	nil	8086
pop	reg32			32	58+$1		nil	nil	386
pop	REG_DS			nil	1F		nil	nil	8086
pop	REG_ES			nil	07		nil	nil	8086
pop	REG_SS			nil	17		nil	nil	8086
pop	REG_FS			nil	0F,A1		nil	nil	386
pop	REG_GS			nil	0F,A9		nil	nil	386
popa!onebyte		61		8086
popad!onebyte32		61
popaw!onebyte16		61
popf!onebyte		9D		8086
popfd!onebyte32		9D
popfw!onebyte16		9D
por!mmxsse		EB		P5		KATMAI,SSE
prefetcht0	mem		nil	0F,18		$1,1	nil	KATMAI
prefetcht1	mem		nil	0F,18		$1,2	nil	KATMAI
prefetcht2	mem		nil	0F,18		$1,3	nil	KATMAI
prefetchnta	mem		nil	0F,18		$1,0	nil	KATMAI
psadbw!mmxsse		F6		KATMAI		KATMAI,SSE
pshufd!sse2pdimm	70
pshufhw	XMMREG,rm128,imm8	nil	F3,0F,70	$2,$1	$3,8	P4,SSE2
pshuflw	XMMREG,rm128,imm8	nil	F2,0F,70	$2,$1	$3,8	P4,SSE2
pshufw	MMXREG,rm64,imm8	nil	0F,70		$2,$1	$3,8	KATMAI,MMX
pslldq	XMMREG,imm8		nil	66,0F,73	$1r,7	$2,8	P4,SSE2
psllw!pshift		F1,71,6
pslld!pshift		F2,72,6
psllq!pshift		F3,73,6
psraw!pshift		E1,71,4
psrad!pshift		E2,72,4
psrldq	XMMREG,imm8		nil	66,0F,73	$1r,3	$2,8	P4,SSE2
psrlw!pshift		D1,71,2
psrld!pshift		D2,72,2
psrlq!pshift		D3,73,2
psubb	MMXREG,imm8		nil	0F,F8		$1r,2	$2,8	P5,MMX
psubb	XMMREG,imm8		nil	66,0F,F8	$1r,2	$2,8	P4,SSE2
psubw	MMXREG,imm8		nil	0F,F9		$1r,2	$2,8	P5,MMX
psubw	XMMREG,imm8		nil	66,0F,F9	$1r,2	$2,8	P4,SSE2
psubd!mmxsse		FA		P5		P4,SSE2
psubq!mmxsse		FB		P5		P4,SSE2
psubsb!mmxsse		E8		P5		P4,SSE2
psubsw!mmxsse		E9		P5		P4,SSE2
psubusb!mmxsse		D8		P5		P4,SSE2
psubusw!mmxsse		D9		P5		P4,SSE2
punpckhbw!mmxsse	68		P5		P4,SSE2
punpckhwd!mmxsse	69		P5		P4,SSE2
punpckhdq!mmxsse	6A		P5		P4,SSE2
punpckhqdq!sse2pd	6D
punpcklbw!mmxsse	60		P5		P4,SSE2
punpcklwd!mmxsse	61		P5		P4,SSE2
punpckldq!mmxsse	62		P5		P4,SSE2
punpcklqdq!sse2pd	6C
push	mem16x			16	FF		$1,6	nil	8086
push	mem32x			32	FF		$1,6	nil	386
push	reg16			16	50+$1		nil	nil	8086
push	reg32			32	50+$1		nil	nil	386
push	imm8x			nil	6A		nil	$1,8	8086
push	imm16x			16	68		nil	$1,16	8086
push	imm32x			32	68		nil	$1,32	386
push	REG_CS			nil	0E		nil	nil	8086
push	REG_SS			nil	16		nil	nil	8086
push	REG_DS			nil	1E		nil	nil	8086
push	REG_ES			nil	06		nil	nil	8086
push	REG_FS			nil	0F,A0		nil	nil	386
push	REG_GS			nil	0F,A8		nil	nil	386
pusha!onebyte		60		8086
pushad!onebyte32	60
pushaw!onebyte16	60
pushf!onebyte		9C		8086
pushfd!onebyte32	9C
pushfw!onebyte16	9C
pxor!mmxsse		EF		P5		P4,SSE2
rcl!shift		2
rcr!shift		3
rol!shift		0
ror!shift		1
rcpps!sseps		53		KATMAI,SSE
rcpss!sse2ss		53
rdmsr!twobyte		0F,32		P5,PRIV
rdpmc!twobyte		0F,33		P6
rdtsc!twobyte		0F,31		P5
:ret	retn
retn	nil			nil	C3		nil	nil	8086
retf	nil			nil	CB		nil	nil	8086
retn	imm16			nil	C2		nil	$1,16	8086
retf	imm16			nil	CA		nil	$1,16	8086
rsm	nil			nil	0F,AA		nil	nil	P5,SMM
rsqrtps!sseps		52		KATMAI,SSE
rsqrtss!sse2ss		52
sahf!onebyte		9E		8086
sal!shift		4
sar!shift		7
shl!shift		4
shr!shift		5
sbb!arith		18,3
scasb!onebyte		AE		8086
scasw!onebyte16		AF
scasd!onebyte32		AF
; setcc
;sfence	nil			nil	0F,AE		,7?
sgdt	mem			nil	0F,01		$1,0	nil	286
sidt	mem			nil	0F,01		$1,1	nil	286
shld!shlrd		A4
shrd!shlrd		AC
shufpd!sse2pdimm	C6
shufps!ssepsimm		C6
sldt	mem1632			nil	0F,00		$1,0	nil	286
sldt	reg16			16	0F,00		$1r,0	nil	286
sldt	reg32			32	0F,00		$1r,0	nil	386
smsw	mem1632			nil	0F,01		$1,4	nil	286
smsw	reg16			16	0F,01		$1r,4	nil	286
smsw	reg32			32	0F,01		$1r,4	nil	386
sqrtpd!sse2pd		51
sqrtps!sseps		51		KATMAI,SSE
sqrtsd!sse2sd		51
sqrtss!sse2ss		51
stc!onebyte		F9		8086
std!onebyte		FD		8086
sti!onebyte		FB		8086
stmxcsr	mem32			nil	0F,AE		$1,3	nil	KATMAI,SSE
stosb!onebyte		AA		8086
stosw!onebyte16		AB
stosd!onebyte32		AB
str!prot286		1
sub!arith		28,5
subpd!sse2pd		5C
subps!sseps		5C		KATMAI,SSE
subsd!sse2sd		5C
subss!sse2ss		5C
sysenter!twobyte	0F,34		P6
sysexit!twobyte		0F,35		P6,PRIV
test	REG_AL,imm8		nil	A8		nil	$2,8	8086
test	REG_AX,imm16		16	A9		nil	$2,16	8086
test	REG_EAX,imm32		32	A9		nil	$2,32	386
test	reg8,imm		nil	F6		$1r,0	$2,8	8086
test	mem8x,imm		nil	F6		$1,0	$2,8	8086
test	reg8,imm8x		nil	F6		$1r,0	$2,8	8086
test	mem,imm8x		nil	F6		$1,0	$2,8	8086
test	reg16,imm		16	F7		$1r,0	$2,16	8086
test	mem16x,imm		16	F7		$1,0	$2,16	8086
test	reg16,imm16x		16	F7		$1r,0	$2,16	8086
test	mem,imm16x		16	F7		$1,0	$2,16	8086
test	reg32,imm		32	F7		$1r,0	$2,32	386
test	mem32x,imm		32	F7		$1,0	$2,32	386
test	reg32,imm32x		32	F7		$1r,0	$2,32	386
test	mem,imm32x		32	F7		$1,0	$2,32	386
; opcode arbitrarily picked for next 3 (could be 32/33 instead of 30/31).
test	reg8,reg8		nil	84		$1r,$2	nil	8086
test	reg16,reg16		16	85		$1r,$2	nil	8086
test	reg32,reg32		32	85		$1r,$2	nil	386
test	mem,reg8		nil	84		$1,$2	nil	8086
test	mem8x,reg8		nil	84		$1,$2	nil	8086
test	mem,reg16		16	85		$1,$2	nil	8086
test	mem16x,reg16		16	85		$1,$2	nil	8086
test	mem,reg32		32	85		$1,$2	nil	386
test	mem32x,reg32		32	85		$1,$2	nil	386
test	reg8,mem8		nil	84		$2,$1	nil	8086
test	reg16,mem16		16	85		$2,$1	nil	8086
test	reg32,mem32		32	85		$2,$1	nil	386
ucomisd!sse2sd		2E
ucomiss!sse2ss		2E
ud2!twobyte		0F,0B		286
unpckhpd!sse2pd		15
unpckhps!sseps		15		KATMAI,SSE
unpcklpd!sse2pd		14
unpcklps!sseps		14		KATMAI,SSE
verr!prot286		4
verw!prot286		5
wait!onebyte		9B		8086
fwait!onebyte		9B		8086,FPU
wbinvd!twobyte		0F,09		486,PRIV
wrmsr!twobyte		0F,30		P5,PRIV
xadd!cmpxchgxadd	C0
;xchg	REG_AX,reg16		16	90+$2		nil	nil	8086
;xchg	reg16,REG_AX		16	90+$1		nil	nil	8086
;xchg	REG_EAX,reg32		32	90+$2		nil	nil	386
;xchg	reg32,REG_EAX		32	90+$1		nil	nil	386
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
xchg	reg8,reg8		nil	86		$1r,$2	nil	8086
xchg	mem,reg8		nil	86		$1,$2	nil	8086
xchg	mem8x,reg8		nil	86		$1,$2	nil	8086
xchg	reg8,mem8		nil	86		$2,$1	nil	8086
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
xchg	reg16,reg16		16	87		$1r,$2	nil	8086
xchg	mem,reg16		16	87		$1,$2	nil	8086
xchg	mem16x,reg16		16	87		$1,$2	nil	8086
xchg	reg16,mem16		16	87		$2,$1	nil	8086
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
xchg	reg32,reg32		32	87		$1r,$2	nil	386
xchg	mem,reg32		32	87		$1,$2	nil	386
xchg	mem32x,reg32		32	87		$1,$2	nil	386
xchg	reg32,mem32		32	87		$2,$1	nil	386
xlat!onebyte		D7		8086
xlatb!onebyte		D7		8086
xor!arith		30,6
xorpd!sse2pd		57
xorps!sseps		57		KATMAI,SSE
;
; Obsolete/Undocumented Instructions
;
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
cmpxchg486	reg8,reg8	nil	0F,A6		$1r,$2	nil	486,UNDOC
cmpxchg486	mem,reg8	nil	0F,A6		$1,$2	nil	486,UNDOC
cmpxchg486	mem8x,reg8	nil	0F,A6		$1,$2	nil	486,UNDOC
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
cmpxchg486	reg16,reg16	16	0F,A7		$1r,$2	nil	486,UNDOC
cmpxchg486	mem,reg16	16	0F,A7		$1,$2	nil	486,UNDOC
cmpxchg486	mem16x,reg16	16	0F,A7		$1,$2	nil	486,UNDOC
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
cmpxchg486	reg32,reg32	32	0F,A7		$1r,$2	nil	486,UNDOC
cmpxchg486	mem,reg32	32	0F,A7		$1,$2	nil	486,UNDOC
cmpxchg486	mem32x,reg32	32	0F,A7		$1,$2	nil	486,UNDOC
ffreep	fpureg			nil	DF,C0+$1	nil	nil	P6,FPU,UNDOC
fsetpm!twobyte		DB,E4		286,FPU,OBS
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
ibts	reg16,reg16		16	0F,A7		$1r,$2	nil	386,UNDOC,OBS
ibts	mem,reg16		16	0F,A7		$1,$2	nil	386,UNDOC,OBS
ibts	mem16x,reg16		16	0F,A7		$1,$2	nil	386,UNDOC,OBS
; arbitrary encoding, picked $1r,$2 instead of $2r,$1
ibts	reg32,reg32		32	0F,A7		$1r,$2	nil	386,UNDOC,OBS
ibts	mem,reg32		32	0F,A7		$1,$2	nil	386,UNDOC,OBS
ibts	mem32x,reg32		32	0F,A7		$1,$2	nil	386,UNDOC,OBS
loadall!twobyte		0F,07		386,UNDOC
loadall286!twobyte	0F,05		286,UNDOC
;pop	REG_CS			nil	0F		nil	nil	8086,UNDOC,OBS
salc!onebyte		D6		8086,UNDOC
smi!onebyte		F1		386,UNDOC
ud1!twobyte		0F,B9		286,UNDOC
; opcode arbitrarily picked for next 3 (could be 12/13 instead of 10/11).
umov	reg8,reg8		nil	0F,10		$1r,$2	nil	386,UNDOC
umov	reg16,reg16		16	0F,11		$1r,$2	nil	386,UNDOC
umov	reg32,reg32		32	0F,11		$1r,$2	nil	386,UNDOC
umov	mem,reg8		nil	0F,10		$1,$2	nil	386,UNDOC
umov	mem8x,reg8		nil	0F,10		$1,$2	nil	386,UNDOC
umov	mem,reg16		16	0F,11		$1,$2	nil	386,UNDOC
umov	mem16x,reg16		16	0F,11		$1,$2	nil	386,UNDOC
umov	mem,reg32		32	0F,11		$1,$2	nil	386,UNDOC
umov	mem32x,reg32		32	0F,11		$1,$2	nil	386,UNDOC
umov	reg8,mem8		nil	0F,12		$2,$1	nil	386,UNDOC
umov	reg16,mem16		16	0F,13		$2,$1	nil	386,UNDOC
umov	reg32,mem32		32	0F,13		$2,$1	nil	386,UNDOC
xbts	reg16,mem16		16	0F,A6		$2,$1	nil	386,UNDOC,OBS
xbts	reg32,mem32		32	0F,A6		$2,$1	nil	386,UNDOC,OBS
;
; AMD 3DNow! Instructions
;
femms!twobyte		0F,0E		P5,3DNOW,AMD
pavgusb!now3d		BF		P5
pf2id!now3d		1D		P5
pf2iw!now3d		1C		ATHLON
pfacc!now3d		AE		P5
pfadd!now3d		9E		P5
pfcmpeq!now3d		B0		P5
pfcmpge!now3d		90		P5
pfcmpgt!now3d		A0		P5
pfmax!now3d		A4		P5
pfmin!now3d		94		P5
pfmul!now3d		B4		P5
pfnacc!now3d		8A		ATHLON
pfpnacc!now3d		8E		ATHLON
pfrcp!now3d		96		P5
pfrcpit1!now3d		A6		P5
pfrcpit2!now3d		B6		P5
pfrsqit1!now3d		A7		P5
pfrsqrt!now3d		97		P5
pfsub!now3d		9A		P5
pfsubr!now3d		AA		P5
pi2fd!now3d		0D		P5
pi2fw!now3d		0C		ATHLON
pmulhrwa!now3d		B7		P5
prefetch	mem		nil	0F,0D		$1,0	nil	P5,3DNOW,AMD
prefetchw	mem		nil	0F,0D		$1,1	nil	P5,3DNOW,AMD
pswapd!now3d		BB		ATHLON
;
; Other AMD Instructions
;
syscall!twobyte		0F,05		P6,AMD
sysret!twobyte		0F,07		P6,PRIV,AMD
;
; Cyrix Instructions
;
paddsiw!cyrixmmx	51
paveb!cyrixmmx		50
pdistib!cyrixmmx	54
pmachriw	MMXREG,mem64	nil	0F,5E		$2,$1	nil	P5,MMX,CYRIX
pmagw!cyrixmmx		52
pmulhriw!cyrixmmx	5D
pmulhrwc!cyrixmmx	59
pmvgezb!cyrixmmx	5C
pmvlzb!cyrixmmx		5B
pmvnzb!cyrixmmx		5A
pmvzb!cyrixmmx		58
psubsiw!cyrixmmx	55
rdshr!twobyte		0F,36		P6,CYRIX,SMM
rsdc	segreg,mem80		nil	0F,79		$2,$1	nil	486,CYRIX,SMM
rsldt!cyrixsmm		7B
rsts!cyrixsmm		7D
smint!twobyte		0F,38		P6,CYRIX
smintold!twobyte	0F,7E		486,CYRIX,OBS
svdc	mem80,segreg		nil	0F,78		$1,$2	nil	486,CYRIX,SMM
svldt!cyrixsmm		7A
svts!cyrixsmm		7C
wrshr!twobyte		0F,37		P6,CYRIX,SMM
