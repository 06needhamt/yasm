#!/usr/bin/env python

template = \
"""
#cdef public class _%(pytypename)s(_CObject)[ object AdaptObj_%(pytypename)s, type AdaptType_%(pytypename)s ]:
cdef class _%(pytypename)s(_CObject):
  def __init__( self, value = None, addr = None ):
    cdef %(ctypename)s*p
    cdef long c_addr
    cdef _CObject cobject
    if addr is None:
      p = <%(ctypename)s*>pyx_calloc(1,sizeof(%(ctypename)s))
      self.p = <void*>p
      if isinstance(value,CObject):
        if isinstance(value,_%(pytypename)s):
          cobject = value
          p[0] = (<%(ctypename)s*>cobject.p)[0]
        else:
          value.init_%(pytypename)s(self)
      elif value is not None:
        p[0] = value
      else:
        p[0] = 0
      self.malloced = True
    else:
      c_addr = addr
      self.p = <void*>c_addr
      self.malloced = False
  def __int__( self ):
    cdef %(ctypename)s *p
    assert self.p != NULL
    p = <%(ctypename)s*>self.p
    return int(p[0])
  def __float__( self ):
    cdef %(ctypename)s *p
    assert self.p != NULL
    p = <%(ctypename)s*>self.p
    return float(p[0])
  def __add__( x, y ):
    cdef %(ctypename)s val
    cdef _%(pytypename)s self
    if not isinstance(x,%(pytypename)s):
      x,y = y,x
    self = x
    assert self.p != NULL
    val = (<%(ctypename)s*>self.p)[0]
    val = val + y
    return %(pytypename)s(val)
  def __sub__( x, y ):
    cdef %(ctypename)s val
    cdef _%(pytypename)s self
    if not isinstance(x,%(pytypename)s):
      x,y = y,x
    self = x
    assert self.p != NULL
    val = (<%(ctypename)s*>self.p)[0]
    val = val - y
    return %(pytypename)s(val)
  def __mul__( x, y ):
    cdef %(ctypename)s val
    cdef _%(pytypename)s self
    if not isinstance(x,%(pytypename)s):
      x,y = y,x
    self = x
    assert self.p != NULL
    val = (<%(ctypename)s*>self.p)[0]
    val = val + y
    return %(pytypename)s(val)
  def __repr__( self ):
    cdef long c_addr
    cdef %(ctypename)s c_val
    c_addr = <long>self.p
    value = ""
    if c_addr != 0:
      c_val = (<%(ctypename)s*>self.p)[0]
      value = ", value = %%s" %% str( c_val )
    return "%%s( addr = %%s%%s )" %% (self.__class__.__name__, hex(c_addr), value)
  def set_value( self, value ):
    if isinstance(value,CObject):
      value.init_%(pytypename)s(self)
    else:
      (<%(ctypename)s*>self.p)[0] = value
  def get_value( self ):
    return (<%(ctypename)s*>self.p)[0]
  def to_%(pytypename)s(self):
    return self
  def init_from( self, _%(pytypename)s cobject ):
    " init self from a %(pytypename)s instance "
#    if not self.is_compatible(cobject):
    if not isinstance( cobject, %(pytypename)s ):
      raise TypeError("%%s cannot be set from %%s" %% (self.__class__, cobject))
    (<%(ctypename)s*>self.p)[0] = (<%(ctypename)s*>cobject.p)[0]
  def get_basetype( self ):
    return %(pytypename)s
#  def sizeof( self ):
#    return sizeof(%(ctypename)s)
#  def is_compatible( self, _CObject cobject ):
#    return isinstance( cobject, %(pytypename)s )
"""

to_func = """\
  def to_%(pytarget)s( self ):
    " cast self to new %(pytarget)s instance "
    cdef %(csource)s c_src
    cdef %(ctarget)s c_tgt
    cdef _%(pysource)s py_src
    cdef _%(pytarget)s py_tgt
    c_src = (<%(csource)s*>self.p)[0]
    c_tgt = <%(ctarget)s>c_src
    py_tgt = %(pytarget)s()
    (<%(ctarget)s*>py_tgt.p)[0] = c_tgt
    return py_tgt
"""
from_func = """\
  def from_%(pytarget)s( self, _%(pytarget)s cobject ):
    " set self from a %(pytarget)s instance"
    (<%(csource)s*>self.p)[0] = <%(csource)s>(<%(ctarget)s*>cobject.p)[0]
"""
init_func = """\
  def init_%(pytarget)s( self, _%(pytarget)s cobject ):
    " set a %(pytarget)s instance from self "
    (<%(ctarget)s*>cobject.p)[0] = <%(ctarget)s>(<%(csource)s*>self.p)[0]
"""

str_tmpl = """\
  def __str__( self ):
    cdef long c_addr
    cdef %(ctypename)s c_val
    c_addr = <long>self.p
    value = ""
    if c_addr != 0:
      c_val = (<%(ctypename)s*>self.p)[0]
      value = str( c_val )
    return value
"""

tps = """\
CChar char
CSChar signed char
CUChar unsigned char
CShort short
CUShort unsigned short
CInt int
CUInt unsigned int
CLong long
CULong unsigned long
CLLong long long
CULLong unsigned long long
CFloat float
CDouble double
CLDouble long double """.split('\n')

tps = [ ( tp.split()[0], ' '.join(tp.split()[1:]) ) for tp in tps ]

tps = [ {'pytypename':tp[0], 'ctypename':tp[1]} for tp in tps ]

#print tps

import sys
#pxifile = open("_adapt.pxi","w")
pxifile = sys.argv[1]
pxdfile = sys.argv[2]
assert pxifile.endswith('.pxi')
assert pxdfile.endswith('.pxd')
pxifile = open(pxifile,"w")
pxdfile = open(pxdfile,"w")

print >>pxifile, "# code autogenerated from %s" % __file__
print >>pxifile

for tp in tps:
#  print 'cdef public class _%(pytypename)s(_CObject)[ object AdaptObj_%(pytypename)s, type AdaptType_%(pytypename)s ]' % tp
  print >>pxifile, 'cdef class _%(pytypename)s(_CObject)' % tp
print>>pxifile 

for tp in tps:
  print >>pxifile, template % tp,
#  print '#', tp
  if tp['pytypename'] == 'CChar':
    print >>pxifile, """\
  def __str__( self ):
    cdef int a
    a = (<char*>self.p)[0]
    s = PyString_FromFormat('%c', a)
    return s
""",
  else:
    print >>pxifile, str_tmpl % tp,
  if tp['pytypename'] == 'CInt':
    print >>pxifile, """\
#  def __add__( x, y ):
#    cdef _CInt z
#    if isinstance(x,CInt):
#      z = x
#      return (<int*>z.p)[0] + y
#    elif isinstance(y,CInt):
#      z = y
#      return x + (<int*>z.p)[0]
#    return NotImplemented
#  def __sub__( x, y ):
#    cdef _CInt z
#    if isinstance(x,CInt):
#      z = x
#      return (<int*>z.p)[0] - y
#    elif isinstance(y,CInt):
#      z = y
#      return x - (<int*>z.p)[0]
#    return NotImplemented
""",
  for _tp in tps:
    print >>pxifile, from_func % \
      { 'csource':tp['ctypename'], 'pysource':tp['pytypename'],
        'ctarget':_tp['ctypename'], 'pytarget':_tp['pytypename'] },
    print >>pxifile, init_func % \
      { 'csource':tp['ctypename'], 'pysource':tp['pytypename'],
        'ctarget':_tp['ctypename'], 'pytarget':_tp['pytypename'] },
    if _tp == tp:
      continue
    print >>pxifile, to_func % \
      { 'csource':tp['ctypename'], 'pysource':tp['pytypename'],
        'ctarget':_tp['ctypename'], 'pytarget':_tp['pytypename'] },

  print >>pxifile, "%(pytypename)s = Meta('%(pytypename)s', (_%(pytypename)s,), {} )" % tp
  print >>pxifile, "%(pytypename)s.basetype = %(pytypename)s" % tp
  print >>pxifile, "%(pytypename)s.sizeof = sizeof(%(ctypename)s)" % tp


pxdheader = \
"""

cdef extern from *:
  ctypedef unsigned int __c_size_t "size_t"

cdef extern from "object.h":
  ctypedef class __builtin__.type [object PyHeapTypeObject]:
    pass

cdef class Meta(type):
  pass

cdef class _CObject:
#cdef public class _CObject [ object AdaptObj_CObject, type AdaptType_CObject ]:
  cdef void*p
  cdef int malloced
  cdef public object incref # incref what we are pointing to

cdef class _CPointer(_CObject):
  pass

cdef class _CArray(_CPointer):
  cdef public __c_size_t el_size # sizeof what we point to # XX class attr ??
  cdef __c_size_t nmemb
  cdef void *items

"""

pxdfile.write( pxdheader )

for tp in tps:
#  print 'cdef public class _%(pytypename)s(_CObject)[ object AdaptObj_%(pytypename)s, type AdaptType_%(pytypename)s ]' % tp
  print >>pxdfile, 'cdef class _%(pytypename)s(_CObject):\n  pass' % tp
print >>pxdfile, 'cdef class _CStruct(_CObject):\n  pass'


